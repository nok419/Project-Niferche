# src

## Directory Structure

- src/
  - App.tsx
  - main.tsx
  - types/
    - laboratory.ts
    - badges.ts
    - common.ts
    - content.ts
    - materials.ts
    - auth.ts
  - contexts/
    - BadgeContext.tsx
    - SessionContext.tsx
  - .DS_Store (binary file)
  - App.css
  - utils/
    - cache.tsx
    - storage.tsx
  - index.css
  - components/
    - materials/
      - DocumentFilter.tsx
      - MaterialsLayout.tsx
      - DocumentCard.tsx
    - auth/
      - ProtectedRoute.tsx
    - layout/
      - LibraryLayout.tsx
      - AuthLayout.tsx
      - CallLayout.tsx
      - LaboratoryLayout.tsx
      - MainLayout.tsx
      - MaterialsRootLayout.tsx
      - navigation-header.tsx
    - content/
      - StoryViewer.tsx
      - ContentDisplay.tsx
      - LazyContent.tsx
    - user/
      - UserMenu.tsx
    - common/
      - SkeletonList.tsx
      - LibraryListViewItem.tsx
      - Meta.tsx
      - LoadingState.css
      - ContentCard.tsx
      - ContentSection.tsx
      - LoadingSpinner.tsx
      - ErrorAlert.tsx
      - AdvancedFilterPanel.tsx
      - DetailModal.tsx
      - ContentCard.css
      - BreadcrumbNav.tsx
      - FavoriteButton.tsx
      - ErrorBoundary.tsx
    - badges/
      - BadgeNotification.tsx
  - vite-env.d.ts
  - theme/
    - index.tsx
    - tokens.tsx
    - laboratory.css
    - components.tsx
    - materialsTheme.tsx
    - laboratoryTheme.tsx
  - hooks/
    - useBadges.ts
    - useInfiniteContents.tsx
    - useContent.tsx
  - assets/
    - react.svg
  - pages/
    - materials/
      - HodemeiMaterials.tsx
      - MaterialDetailPage.tsx
      - AlsarejiaMaterials.tsx
      - QuxeMaterials.tsx
      - MaterialsAbout.tsx
      - CommonSettings.tsx
    - laboratory/
      - IdeaLibrary.tsx
      - LaboratoryPage.tsx
      - FacilityGuide.tsx
      - ArchivePage.tsx
      - GuidePage.tsx
      - ObservationPage.tsx
    - gallery/
      - GalleryPage.tsx
      - GalleryDetailPage.tsx
    - admin/
      - AdminDashboardPage.tsx
    - library/
      - SideStory.tsx
      - MainStory.tsx
      - LibraryOverviewPage.tsx
      - RecordsPage.tsx
      - SideStoryListPage.tsx
      - SideStoryDetailPage.tsx
      - LibraryPage.tsx
    - user/
      - ProfilePage.tsx
      - FavoritesPage.tsx
    - ErrorPage.tsx
    - system/
      - auth/
        - ConfirmSignUpPage.tsx
        - SignInPage.tsx
        - SignUpPage.tsx
      - TermsPage.tsx
      - GuidelinesPage.tsx
      - RightsPage.tsx
    - comingsoon.tsx
    - call/
      - AboutPage.tsx
      - PhilosophyPage.tsx
      - NewsPage.tsx
    - MainPage.tsx
    - NotFoundPage.tsx
  - services/
    - mockStorage.tsx
    - storage.tsx
    - auth.ts

## File Contents

### App.tsx

```
// src/App.tsx

import { BrowserRouter, Routes, Route } from 'react-router-dom';
import { ThemeProvider } from '@aws-amplify/ui-react';

// themes
import { laboratoryTheme } from './theme/laboratoryTheme';
import { theme } from './theme';

// Layouts
import { MainLayout } from './components/layout/MainLayout';
import { CallLayout } from './components/layout/CallLayout';
import { LibraryLayout } from './components/layout/LibraryLayout';
import { LaboratoryLayout } from './components/layout/LaboratoryLayout';
import { MaterialsRootLayout } from './components/layout/MaterialsRootLayout';
import { AuthLayout } from './components/layout/AuthLayout';

// Call Pages
import { AboutPage } from './pages/call/AboutPage';
import { PhilosophyPage } from './pages/call/PhilosophyPage';
import { NewsPage } from './pages/call/NewsPage';

// Library Pages
import { LibraryOverviewPage } from './pages/library/LibraryOverviewPage';
import { MainStory } from './pages/library/MainStory';
import { SideStory } from './pages/library/SideStory';
import { SideStoryListPage } from './pages/library/SideStoryListPage';
import { SideStoryDetailPage } from './pages/library/SideStoryDetailPage';
import { LibraryPage } from './pages/library/LibraryPage';
import { RecordsPage } from './pages/library/RecordsPage';

// Laboratory Pages
import { LaboratoryPage } from './pages/laboratory/LaboratoryPage';
import { ObservationPage } from './pages/laboratory/ObservationPage';
import { ArchivePage } from './pages/laboratory/ArchivePage';
import { GuidePage } from './pages/laboratory/GuidePage';
import { IdeaLibrary } from './pages/laboratory/IdeaLibrary';

// Materials Pages
import { MaterialsAbout } from './pages/materials/MaterialsAbout';
import { CommonSettings } from './pages/materials/CommonSettings';
import { QuxeMaterials } from './pages/materials/QuxeMaterials';
import { HodemeiMaterials } from './pages/materials/HodemeiMaterials';
import { AlsarejiaMaterials } from './pages/materials/AlsarejiaMaterials';

// Gallery Page
import { GalleryPage } from './pages/gallery/GalleryPage';

// System Pages
import { MainPage } from './pages/MainPage';
import { RightsPage } from './pages/system/RightsPage';
import { TermsPage } from './pages/system/TermsPage';
import { GuidelinesPage } from './pages/system/GuidelinesPage';

// Auth Pages
import { SignInPage } from './pages/system/auth/SignInPage';
import { SignUpPage } from './pages/system/auth/SignUpPage';
import { ConfirmSignUpPage } from './pages/system/auth/ConfirmSignUpPage';

// Error / 404
import { NotFoundPage } from './pages/NotFoundPage';
import { ErrorPage } from './pages/ErrorPage';

// Protected
import { ProfilePage } from './pages/user/ProfilePage';
import { FavoritesPage } from './pages/user/FavoritesPage';

import { ErrorBoundary } from './components/common/ErrorBoundary';

// ★ 新規追加ページ
import { GalleryDetailPage } from './pages/gallery/GalleryDetailPage';        
import { MaterialDetailPage } from './pages/materials/MaterialDetailPage';   
import { AdminDashboardPage } from './pages/admin/AdminDashboardPage';       

function App() {
  return (
    <BrowserRouter>
      <ThemeProvider theme={theme}>
        <ErrorBoundary>
          <Routes>

            {/* Auth */}
            <Route path="/auth" element={<AuthLayout />}>
              <Route path="signin" element={<SignInPage />} />
              <Route path="signup" element={<SignUpPage />} />
              <Route path="confirm" element={<ConfirmSignUpPage />} />
            </Route>

            {/* Call */}
            <Route element={<CallLayout />}>
              <Route path="/call/about" element={<AboutPage />} />
              <Route path="/call/philosophy" element={<PhilosophyPage />} />
              <Route path="/call/news" element={<NewsPage />} />
            </Route>

            {/* Library */}
            <Route element={<LibraryLayout />}>
              <Route path="/library" element={<LibraryOverviewPage />} />
              <Route path="/library/mainstory" element={<MainStory />} />
              <Route path="/library/sidestory" element={<SideStory />} />
              <Route path="/library/sidestorylist" element={<SideStoryListPage />} />
              <Route path="/library/sidestory/detail/:storyId" element={<SideStoryDetailPage />} />
              <Route path="/library/records" element={<RecordsPage />} />
              <Route path="/library/page" element={<LibraryPage />} />
            </Route>

            {/* Laboratory */}
            <Route
              element={
                <ThemeProvider theme={laboratoryTheme}>
                  <LaboratoryLayout />
                </ThemeProvider>
              }
            >
              <Route path="/laboratory/about" element={<LaboratoryPage />} />
              <Route path="/laboratory/observation" element={<ObservationPage />} />
              <Route path="/laboratory/archive" element={<ArchivePage />} />
              <Route path="/laboratory/guide" element={<GuidePage />} />
              <Route path="/laboratory/ideas" element={<IdeaLibrary />} />
            </Route>

            {/* Materials */}
            <Route element={<MaterialsRootLayout />}>
              <Route path="/materials/about" element={<MaterialsAbout />} />
              <Route path="/materials/common" element={<CommonSettings />} />
              <Route path="/materials/quxe" element={<QuxeMaterials />} />
              <Route path="/materials/hodemei" element={<HodemeiMaterials />} />
              <Route path="/materials/alsarejia" element={<AlsarejiaMaterials />} />
              {/* 詳細ルート */}
              <Route 
                path="/materials/:attribution/:world/:materialId" 
                element={<MaterialDetailPage />} 
              />
            </Route>

            {/* Gallery */}
            <Route element={<MainLayout />}>
              <Route path="/gallery" element={<GalleryPage />} />
              {/* ギャラリ詳細ルート */}
              <Route path="/gallery/view/:galleryId" element={<GalleryDetailPage />} />

              <Route path="/rights" element={<RightsPage />} />
              <Route path="/terms" element={<TermsPage />} />
              <Route path="/guidelines" element={<GuidelinesPage />} />
            </Route>

            {/* プロフィール・お気に入り */}
            <Route path="/profile" element={<ProfilePage />} />
            <Route path="/favorites" element={<FavoritesPage />} />
            
            {/* 管理者ページ */}
            <Route path="/admin" element={<AdminDashboardPage />} />

            {/* メイン */}
            <Route path="/" element={<MainLayout />}>
              <Route index element={<MainPage />} />
            </Route>

            {/* エラー */}
            <Route path="/error" element={<ErrorPage />} />
            <Route path="*" element={<NotFoundPage />} />

          </Routes>
        </ErrorBoundary>
      </ThemeProvider>
    </BrowserRouter>
  );
}

export default App;
```

### main.tsx

```
import React from 'react';
import ReactDOM from 'react-dom/client';
import { HelmetProvider } from 'react-helmet-async';
import '@aws-amplify/ui-react/styles.css';
import App from './App';

// アプリケーションのレンダリング
const root = ReactDOM.createRoot(
  document.getElementById('root') as HTMLElement
);

root.render(
  <React.StrictMode>
    <HelmetProvider>
      <App />
    </HelmetProvider>
  </React.StrictMode>
);
```

### types/laboratory.ts

```
// src/types/laboratory.ts
import { BaseContent, ContentVariant } from './common';

// ラボラトリーのカテゴリ
export enum LabCategory {
  FACILITY = 'FACILITY',
  RESEARCH = 'RESEARCH',
  RULES = 'RULES',
  IDEA = 'IDEA',
  OBSERVATION = 'OBSERVATION'
}

// ラボラトリードキュメントインターフェース
export interface LabDocument extends BaseContent {
  category: LabCategory;
  variant: ContentVariant;
  hasDetail?: boolean;
}

// ラボラトリーフィルタリングオプション
export interface LabFilterOptions {
  category?: LabCategory;
  variant?: ContentVariant;
  isAvailable?: boolean;
  hasDetail?: boolean;
}

// ラボラトリーフィルタリングヘルパー関数
export function filterLabDocuments(documents: LabDocument[], options?: LabFilterOptions): LabDocument[] {
  if (!options) return documents;
  
  return documents.filter(doc => {
    // 利用可能かのチェック
    if (options.isAvailable !== undefined && doc.isAvailable !== options.isAvailable) {
      return false;
    }
    
    // カテゴリチェック
    if (options.category && doc.category !== options.category) {
      return false;
    }
    
    // 種類チェック
    if (options.variant && doc.variant !== options.variant) {
      return false;
    }
    
    // 詳細の有無チェック
    if (options.hasDetail !== undefined && doc.hasDetail !== options.hasDetail) {
      return false;
    }
    
    return true;
  });
}
```

### types/badges.ts

```
// src/types/badges.ts
import { ApiResponse } from './common';

// バッジ獲得条件タイプ
export enum BadgeRequirementType {
  LOGIN = 'LOGIN',
  READ_CONTENT = 'READ_CONTENT',
  VISIT_PAGE = 'VISIT_PAGE',
  CLICK_ACTION = 'CLICK_ACTION'
}

// バッジの型定義
export interface Badge {
  id: string;
  name: string;
  description: string;
  iconUrl: string;
  requirementType: BadgeRequirementType;
  requirement: string;
  priority: number;
  isSecret: boolean;
  createdAt: string;
  updatedAt: string;
}

// バッジの進捗状況の型定義
export interface BadgeProgress {
  id: string;
  userId: string;
  badgeId: string;
  progress: number;
  isCompleted: boolean;
  completedAt: string | null;
  lastUpdatedAt: string;
  createdAt: string;
  updatedAt: string;
}

// バッジ通知用インターフェース
export interface BadgeNotification {
  badge: Badge;
  progress: BadgeProgress;
  isNew: boolean;
}

// APIから返されるバッジデータ
export interface ApiBadge {
  id: string;
  name: string;
  description: string;
  imageKey?: string;
  requirementType: BadgeRequirementType;
  requirement: string;
  priority: number;
  isSecret: boolean;
  createdAt: string;
  updatedAt?: string;
}

// APIレスポンス型
export type BadgeApiResponse = ApiResponse<ApiBadge[]>;
export type BadgeProgressApiResponse = ApiResponse<BadgeProgress[]>;

// バッジデータ変換関数
export function transformToBadge(data: ApiBadge): Badge {
  return {
    id: data.id,
    name: data.name,
    description: data.description,
    iconUrl: data.imageKey ? `/images/badges/${data.imageKey}` : '/images/badges/default.png',
    requirementType: data.requirementType,
    requirement: data.requirement,
    priority: data.priority,
    isSecret: data.isSecret,
    createdAt: data.createdAt,
    updatedAt: data.updatedAt || data.createdAt
  };
}

// バッジ進捗データ変換関数
export function transformToBadgeProgress(data: any): BadgeProgress {
  return {
    id: data.id,
    userId: data.userId,
    badgeId: data.badgeId,
    progress: data.progress,
    isCompleted: data.isCompleted,
    completedAt: data.completedAt || null,
    lastUpdatedAt: data.lastUpdatedAt,
    createdAt: data.createdAt || data.lastUpdatedAt,
    updatedAt: data.updatedAt || data.lastUpdatedAt
  };
}

// バッジヘルパー関数
export function getBadgeNotification(badge: Badge, progress: BadgeProgress, isNew: boolean = false): BadgeNotification {
  return {
    badge,
    progress,
    isNew
  };
}
```

### types/common.ts

```
// src/types/common.ts

// 基本的なコンテンツインターフェース
export interface BaseContent {
  id: string;
  title: string;
  description: string;
  isAvailable: boolean;
  imagePath?: string;
  reference?: string;
}

// コンテンツの種類
export type ContentVariant = 'document' | 'image' | 'story' | 'interactive';

// アクセスレベル (amplify/data/resource.ts の Visibility に対応)
export enum ContentVisibility {
  PUBLIC = 'PUBLIC',             // 誰でも閲覧可能
  AUTHENTICATED = 'AUTHENTICATED', // ログインユーザーのみ閲覧可能
  PRIVATE = 'PRIVATE'           // 所有者のみアクセス可能
}

// コンテンツステータス
export enum ContentStatus {
  DRAFT = 'DRAFT',         // 下書き
  REVIEW = 'REVIEW',       // レビュー中
  PUBLISHED = 'PUBLISHED', // 公開済み
  ARCHIVED = 'ARCHIVED'    // アーカイブ済み
}

// 世界設定カテゴリ
export enum WorldCategory {
  COMMON = 'COMMON',       // 共通
  QUXE = 'QUXE',           // クーシェ
  HODEMEI = 'HODEMEI',     // ホウデメイ
  ALSAREJIA = 'ALSAREJIA'  // アルサレジア
}

// データソース属性
export enum Attribution {
  OFFICIAL = 'OFFICIAL',   // 公式コンテンツ
  SHARED = 'SHARED'        // 共有コンテンツ
}

// API共通エラー型
export interface ApiError extends Error {
  code?: string;
  name: string;
  statusCode?: number;
}

// API共通レスポンス型
export interface ApiResponse<T> {
  data: T | null;
  errors?: ApiError[];
  nextToken?: string | null;
}

// ページネーション用オプション
export interface PaginationOptions {
  limit?: number;
  nextToken?: string | null;
}

// フィルタリング用オプション
export interface FilterOptions {
  [key: string]: string | number | boolean | null | undefined;
}

// 一般的なリクエストオプション
export interface RequestOptions extends PaginationOptions {
  filter?: FilterOptions;
}
```

### types/content.ts

```
// src/types/content.ts

// コンテンツカテゴリ
export enum ContentCategory {
  MAIN_STORY = 'MAIN_STORY',
  SIDE_STORY = 'SIDE_STORY', 
  SETTING_MATERIAL = 'SETTING_MATERIAL',
  CHARACTER = 'CHARACTER',
  ORGANIZATION = 'ORGANIZATION',
  THEORY = 'THEORY',
  MERCHANDISE = 'MERCHANDISE',
  SITE_INFO = 'SITE_INFO'
}

// コンテンツ参照タイプ
export enum ReferenceType {
  BASED_ON = 'BASED_ON',
  INSPIRED_BY = 'INSPIRED_BY',
  EXTENDS = 'EXTENDS',
  RELATED = 'RELATED'
}

// コンテンツ参照
export interface ContentReference {
  contentId: string;
  relationType: ReferenceType;
}

// 拡張コンテンツインターフェース
export interface Content {
  id: string;
  title: string;
  description: string;
  primaryTypes: string[];
  supplementaryTypes?: string[];
  primaryCategory: string;
  secondaryCategories?: string[];
  worldType: string;
  attribution: string;
  visibility: string;
  status: string;
  tags?: string[];
  sourceRefs?: ContentReference[];
  relatedContent?: ContentReference[];
  characterRefs?: string[];
  itemRefs?: string[];
  createdAt: string;
  updatedAt: string;
  version: string;
  mainKey: string;
  thumbnailKey?: string;
  attachments?: string[];
  ownerId: string;
  collaborators?: string[];
}

// コメント型
export interface Comment {
  id: string;
  contentId: string;
  authorId: string;
  text: string;
  createdAt: string;
  status: 'ACTIVE' | 'HIDDEN' | 'DELETED';
}

// お気に入り項目の型
export interface FavoriteItem {
  contentId: string;
  addedAt: string;
  contentType: string;
}

// コンテンツ取得結果
export interface ContentResult {
  items: Content[];
  nextToken?: string;
}

// コンテンツ管理用ヘルパー関数
export function isContentAccessible(content: Content, isAuthenticated: boolean, userId?: string): boolean {
  // 公開コンテンツは誰でも閲覧可能
  if (content.visibility === 'PUBLIC') {
    return true;
  }

  // 非公開コンテンツは認証が必要
  if (!isAuthenticated) {
    return false;
  }

  // 認証済みコンテンツはログインしていれば閲覧可能
  if (content.visibility === 'AUTHENTICATED') {
    return true;
  }

  // プライベートコンテンツは所有者か共同編集者のみ閲覧可能
  if (content.visibility === 'PRIVATE') {
    if (!userId) return false;
    
    // 所有者または共同編集者かチェック
    return (
      content.ownerId === userId || 
      (content.collaborators ? content.collaborators.includes(userId) : false)
    );
  }

  return false;
}
```

### types/materials.ts

```
// src/types/materials.ts
import { BaseContent, ContentVariant, WorldCategory } from './common';

// マテリアルの種類
export type MaterialVariant = 'manuscript' | 'book' | 'document';

// マテリアルのカテゴリ
export enum MaterialCategory {
  // 共通カテゴリ
  THEORY = 'THEORY',
  LANGUAGE = 'LANGUAGE',
  WORLD = 'WORLD',
  HISTORY = 'HISTORY',
  
  // 施設カテゴリ
  FACILITY = 'FACILITY',
  IDEA = 'IDEA',
  TECH = 'TECH',
  
  // 世界カテゴリ
  MAGIC = 'MAGIC',
  ARTIFACT = 'ARTIFACT',
  TECHNOLOGY = 'TECHNOLOGY',
  
  // 共通要素
  CHARACTER = 'CHARACTER',
  ORGANIZATION = 'ORGANIZATION',
  LOCATION = 'LOCATION'
}

// マテリアルドキュメントインターフェース
export interface MaterialDocument extends BaseContent {
  category: MaterialCategory;
  worldType?: WorldCategory; // オプショナルに変更
  linkTo?: string;
  variant?: MaterialVariant | ContentVariant; // ContentVariantも使用可能に
}

// マテリアルフィルタリングオプション
export interface MaterialFilterOptions {
  category?: MaterialCategory;
  worldType?: WorldCategory;
  variant?: MaterialVariant | ContentVariant;
  isAvailable?: boolean;
}

// マテリアルフィルタリングヘルパー関数
export function filterMaterials(materials: MaterialDocument[], options?: MaterialFilterOptions): MaterialDocument[] {
  if (!options) return materials;
  
  return materials.filter(material => {
    // 利用可能かのチェック
    if (options.isAvailable !== undefined && material.isAvailable !== options.isAvailable) {
      return false;
    }
    
    // カテゴリチェック
    if (options.category && material.category !== options.category) {
      return false;
    }
    
    // 世界タイプチェック
    if (options.worldType && material.worldType !== options.worldType) {
      return false;
    }
    
    // 種類チェック
    if (options.variant && material.variant !== options.variant) {
      return false;
    }
    
    return true;
  });
}

// 表示用テーマ設定
export interface MaterialsThemeTokens {
  colors: {
    background: {
      primary: { value: string };
      secondary: { value: string };
      tertiary: { value: string };
    };
    font: {
      primary: { value: string };
      secondary: { value: string };
      tertiary: { value: string };
    };
    border: {
      primary: { value: string };
      secondary: { value: string };
    };
  };
}
```

### types/auth.ts

```
// src/types/auth.ts
import { UserAttributeKey } from 'aws-amplify/auth';
import { ContentVisibility } from './common';

// アクセスレベルの再定義
export enum AccessLevel {
  PUBLIC = 'PUBLIC',             // 誰でも閲覧可能
  AUTHENTICATED = 'AUTHENTICATED', // ログインユーザーのみ閲覧可能
  OWNER_PUBLIC = 'OWNER_PUBLIC', // 所有者のみ編集可能、他ユーザーは閲覧可能
  OWNER_PRIVATE = 'OWNER_PRIVATE', // 所有者のみアクセス可能
  ADMIN = 'ADMIN'               // 管理者のみアクセス可能
}

// ContentVisibilityからAccessLevelへのマッピング
export function mapVisibilityToAccessLevel(visibility: ContentVisibility): AccessLevel {
  switch (visibility) {
    case ContentVisibility.PUBLIC:
      return AccessLevel.PUBLIC;
    case ContentVisibility.AUTHENTICATED:
      return AccessLevel.AUTHENTICATED;
    case ContentVisibility.PRIVATE:
      return AccessLevel.OWNER_PRIVATE;
    default:
      return AccessLevel.PUBLIC;
  }
}

// ユーザーロールの型定義
export type UserRole = 'user' | 'admin';

// 認証済みユーザー情報の型定義
export interface AuthUser {
  userId: string;
  username: string;
  role: UserRole;
  email?: string;
  nickname?: string;
  attributes?: {
    [key in UserAttributeKey]?: string;
  };
}

// セッションコンテキストで使用するユーザー型
export interface SessionUser {
  username: string;
  attributes?: Record<string, string>;
  userId?: string;
}

// アクセス制御関連型
export interface AccessItem {
  id: string;
  accessLevel: AccessLevel;
  ownerId?: string;
}

// 認証エラー型
export interface AuthError extends Error {
  code?: string;
  name: string;
}

// 認証操作の結果型
export interface AuthResult<T> {
  success: boolean;
  data?: T;
  error?: AuthError;
}

// ユーザーロール取得関数
export function getUserRole(user?: SessionUser): UserRole {
  return (user?.attributes?.['custom:role'] as UserRole) || 'user';
}

// アクセス権限チェック関数
export function hasAccess(user: SessionUser | undefined, item: AccessItem): boolean {
  if (!user) {
    return item.accessLevel === AccessLevel.PUBLIC;
  }

  const userRole = getUserRole(user);
  
  // 管理者は常にアクセス権限を持つ
  if (userRole === 'admin') {
    return true;
  }

  // 所有者チェック
  const isOwner = item.ownerId === user.userId || item.ownerId === user.username;

  switch (item.accessLevel) {
    case AccessLevel.PUBLIC:
      return true;
    case AccessLevel.AUTHENTICATED:
      return true;
    case AccessLevel.OWNER_PUBLIC:
      return isOwner || true; // 読み取りは全ユーザー可能
    case AccessLevel.OWNER_PRIVATE:
      return isOwner;
    case AccessLevel.ADMIN:
      return false; // 管理者チェックは上部で完了している
    default:
      return false;
  }
}
```

### contexts/BadgeContext.tsx

```
// src/contexts/BadgeContext.tsx
import { createContext, useContext, ReactNode, useEffect } from 'react';
import { Badge, BadgeProgress, BadgeRequirementType } from '../types/badges';
import { useBadges } from '../hooks/useBadges';
import { ApiError } from '../types/common';

interface BadgeContextType {
  checkBadgeProgress: (type: BadgeRequirementType, value: string) => Promise<void>;
  userBadges: Badge[];
  badgeProgress: BadgeProgress[];
  isLoading: boolean;
  error: ApiError | null;
}

export const BadgeContext = createContext<BadgeContextType | undefined>(undefined);

export const useBadgeContext = () => {
  const context = useContext(BadgeContext);
  if (!context) {
    throw new Error('useBadgeContext must be used within a BadgeProvider');
  }
  return context;
};

interface BadgeProviderProps {
  children: ReactNode;
}

export const BadgeProvider = ({ children }: BadgeProviderProps) => {
  const {
    userBadges,
    badgeProgress,
    isLoading,
    error,
    checkBadgeProgress
  } = useBadges();

  useEffect(() => {
    // ログイン時のバッジ進捗チェック
    checkBadgeProgress(BadgeRequirementType.LOGIN, 'FIRST_TIME');
  }, []);

  const value = {
    checkBadgeProgress,
    userBadges,
    badgeProgress,
    isLoading,
    error
  };

  return (
    <BadgeContext.Provider value={value}>
      {children}
    </BadgeContext.Provider>
  );
};
```

### contexts/SessionContext.tsx

```
// src/contexts/SessionContext.tsx
import { createContext, useContext, useState, ReactNode } from 'react';
import { SessionUser } from '../types/auth';

/**
 * シンプルなセッションコンテキスト（モックデータ対応）
 */
interface SessionContextType {
  user: SessionUser | null;
  isSignedIn: boolean;
  login: (username: string, password: string) => Promise<boolean>;
  logout: () => void;
}

// モックユーザーデータ
const MOCK_USERS: Record<string, { password: string; data: SessionUser }> = {
  'admin': {
    password: 'password',
    data: {
      username: 'admin',
      userId: 'user-1',
      attributes: {
        email: 'admin@example.com',
        'custom:role': 'admin'
      }
    }
  },
  'user': {
    password: 'password',
    data: {
      username: 'user',
      userId: 'user-2',
      attributes: {
        email: 'user@example.com',
        'custom:role': 'user'
      }
    }
  }
};

const SessionContext = createContext<SessionContextType>({
  user: null,
  isSignedIn: false,
  login: async () => false,
  logout: () => {}
});

export const SessionProvider = ({ children }: { children: ReactNode }) => {
  const [user, setUser] = useState<SessionUser | null>(null);

  const login = async (username: string, password: string): Promise<boolean> => {
    // モックデータでの認証
    const mockUser = MOCK_USERS[username];
    if (mockUser && mockUser.password === password) {
      setUser(mockUser.data);
      return true;
    }
    return false;
  };

  const logout = () => {
    setUser(null);
  };

  return (
    <SessionContext.Provider
      value={{
        user,
        isSignedIn: !!user,
        login,
        logout
      }}
    >
      {children}
    </SessionContext.Provider>
  );
};

export const useSession = () => useContext(SessionContext);
```

### App.css

```
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
  --header-height: 64px;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}

```

### utils/cache.tsx

```
// src/utils/cache.tsx
const CACHE_DURATION = 1000 * 60 * 5; // 5分

interface CacheEntry<T> {
  data: T;
  timestamp: number;
}

export class ContentCache {
  private static cache = new Map<string, CacheEntry<any>>();

  static set<T>(key: string, data: T): void {
    this.cache.set(key, {
      data,
      timestamp: Date.now()
    });
  }

  static get<T>(key: string): T | null {
    const entry = this.cache.get(key);
    if (!entry) return null;

    const isExpired = Date.now() - entry.timestamp > CACHE_DURATION;
    if (isExpired) {
      this.cache.delete(key);
      return null;
    }

    return entry.data as T;
  }
}
```

### utils/storage.tsx

```

// サムネイル用のキー生成
export const generateThumbnailKey = (originalKey: string): string => {
  const parts = originalKey.split('.');
  const extension = parts.pop();
  return `${parts.join('.')}_thumb.${extension}`;
};

// Content-Typeの取得
export const getContentType = (fileName: string): string => {
  const extension = fileName.split('.').pop()?.toLowerCase();
  const contentTypes: { [key: string]: string } = {
    'jpg': 'image/jpeg',
    'jpeg': 'image/jpeg',
    'png': 'image/png',
    'gif': 'image/gif',
    'pdf': 'application/pdf',
    'md': 'text/markdown',
    'mp3': 'audio/mpeg',
    'wav': 'audio/wav',
    // 必要に応じて追加
  };
  return contentTypes[extension || ''] || 'application/octet-stream';
};
```

### index.css

```
body {
  margin: 0;
  background: linear-gradient(180deg, rgb(117, 81, 194), rgb(255, 255, 255));
  display: flex;
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  height: 100vh;
  width: 100vw;
  justify-content: center;
  align-items: center;
}

main {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}

button {
  border-radius: 8px;
  border: 1px solid transparent;
  padding: 0.6em 1.2em;
  font-size: 1em;
  font-weight: 500;
  font-family: inherit;
  background-color: #1a1a1a;
  cursor: pointer;
  transition: border-color 0.25s;
  color: white;
}
button:hover {
  border-color: #646cff;
}
button:focus,
button:focus-visible {
  outline: 4px auto -webkit-focus-ring-color;
}

ul {
  padding-inline-start: 0;
  margin-block-start: 0;
  margin-block-end: 0;
  list-style-type: none;
  display: flex;
  flex-direction: column;
  margin: 8px 0;
  border: 1px solid black;
  gap: 1px;
  background-color: black;
  border-radius: 8px;
  overflow: auto;
}

li {
  background-color: white;
  padding: 8px;
}

li:hover {
  background: #dadbf9;
}

a {
  font-weight: 800;
  text-decoration: none;
}
```

### components/materials/DocumentFilter.tsx

```
// src/components/materials/DocumentFilter.tsx
import { Flex, SearchField, SelectField, ToggleButtonGroup, ToggleButton } from '@aws-amplify/ui-react';

interface DocumentFilterProps {
  onSearch: (term: string) => void;
  onCategoryChange: (category: string) => void;
  onViewChange: (view: 'grid' | 'list') => void; // onViewModeからonViewChangeに修正
  onSortChange: (sort: string) => void;
}

export const DocumentFilter = ({
  onSearch,
  onCategoryChange,
  onViewChange
}: DocumentFilterProps) => {
  return (
    <Flex direction="column" gap="medium" marginBottom="2rem">
      <Flex justifyContent="space-between" alignItems="center" wrap="wrap">
        <SearchField
          label="検索"
          placeholder="キーワードを入力"
          onChange={(e) => onSearch(e.target.value)}
          width="300px"
        />
        
        <Flex gap="medium" alignItems="center">
          <SelectField
            label="カテゴリ"
            onChange={(e) => onCategoryChange(e.target.value)}
          >
            <option value="all">すべて</option>
            <option value="THEORY">理論</option>
            <option value="WORLD">世界</option>
            <option value="LANGUAGE">言語</option>
          </SelectField>

          <ToggleButtonGroup
            value="grid"
            isExclusive
            onChange={(value) => onViewChange(value as 'grid' | 'list')}
          >
            <ToggleButton value="grid">グリッド</ToggleButton>
            <ToggleButton value="list">リスト</ToggleButton>
          </ToggleButtonGroup>
        </Flex>
      </Flex>
    </Flex>
  );
};
```

### components/materials/MaterialsLayout.tsx

```
// src/components/materials/MaterialsLayout.tsx
import { View, Card, Heading, Text, ThemeProvider } from '@aws-amplify/ui-react';
import { materialsTheme, getThemeTokens } from '../../theme/materialsTheme';
import { ReactNode } from 'react';

interface MaterialsLayoutProps {
  title: string;
  description: string;
  children: ReactNode;
}

/**
 * 設定資料ページ専用の「見出し＆背景付きラッパ」コンポーネント。
 * MaterialsRootLayout とは別物：RootLayoutは <Outlet> 用 ルート機構。
 */
export const MaterialsLayout = ({ title, description, children }: MaterialsLayoutProps) => {
  const tokens = getThemeTokens();

  return (
    <ThemeProvider theme={materialsTheme}>
      <View 
        backgroundColor={tokens.colors.background.primary.value}
        minHeight="100vh"
        padding="2rem"
      >
        <Card 
          variation="elevated" 
          padding="2rem" 
          marginBottom="2rem"
          backgroundColor={tokens.colors.background.tertiary.value}
        >
          <Heading level={1}>{title}</Heading>
          <Text marginTop="1rem">{description}</Text>
        </Card>
        <View>{children}</View>
      </View>
    </ThemeProvider>
  );
};

```

### components/materials/DocumentCard.tsx

```
// src/components/materials/DocumentCard.tsx
import { Card, Text, Heading, Badge, Flex } from '@aws-amplify/ui-react';
import { Link } from 'react-router-dom';
import { MaterialDocument } from '../../types/materials';

interface DocumentCardProps extends MaterialDocument {}

export const DocumentCard = ({
  id,
  title,
  description,
  category,
  reference,
  isAvailable,
  linkTo,
  variant = 'document'
}: DocumentCardProps) => {
  return (
    <Card
      key={id}
      variation="elevated"
      padding="1.5rem"
      backgroundColor="#f5f5f0"
      borderRadius="medium"
      className={`document-card document-card--${variant}`}
    >
      <Link 
        to={linkTo || '#'} 
        style={{ textDecoration: 'none', color: 'inherit' }}
        onClick={(e) => {
          if (!isAvailable) {
            e.preventDefault();
            alert('このコンテンツは現在準備中です');
          }
        }}
      >
        <Flex direction="column" gap="medium">
          <Flex justifyContent="space-between" alignItems="center">
            <Badge variation={isAvailable ? 'success' : 'warning'}>
              {isAvailable ? '閲覧可' : '準備中'}
            </Badge>
            {reference && (
              <Text variation="tertiary" fontSize="small">
                {reference}
              </Text>
            )}
          </Flex>
          
          <Heading level={3}>{title}</Heading>
          <Text>{description}</Text>
          
          <Text variation="tertiary" fontSize="small">
            分類: {category}
          </Text>
        </Flex>
      </Link>
    </Card>
  );
};
```

### components/auth/ProtectedRoute.tsx

```
// src/components/auth/ProtectedRoute.tsx
import { Navigate } from 'react-router-dom';
import { useSession } from '../../contexts/SessionContext';
import React from 'react';
import { AccessLevel, getUserRole } from '../../types/auth';

interface ProtectedRouteProps {
  children: React.ReactNode;
  accessLevel?: AccessLevel;
  creatorId?: string;
}

/**
 * 認証が必要なルート用。サインインしていなければ /auth/signin へ。
 * さらにaccessLevelがadminなら、ユーザー属性 custom:role=admin をチェックする。
 */
export const ProtectedRoute = ({
  children,
  accessLevel = AccessLevel.AUTHENTICATED,
  creatorId,
}: ProtectedRouteProps) => {
  const { isSignedIn, user } = useSession();

  // 非認証状態ならログインページへリダイレクト
  if (!isSignedIn) {
    // PUBLICレベルなら認証不要
    if (accessLevel === AccessLevel.PUBLIC) {
      return <>{children}</>;
    }
    return <Navigate to="/auth/signin" replace />;
  }

  // 管理者権限レベルチェック
  if (accessLevel === AccessLevel.ADMIN && user) {
    const userRole = getUserRole(user);
    if (userRole !== 'admin') {
      return <Navigate to="/" replace />;  // 権限不足の場合はホームへリダイレクト
    }
  }

  // 所有者と管理者のみアクセス可能なコンテンツ
  if (accessLevel === AccessLevel.OWNER_PRIVATE && creatorId && user) {
    const userRole = getUserRole(user);
    const isCreator = creatorId === user?.username || creatorId === user?.userId;
    const isAdmin = userRole === 'admin';
    
    if (!isCreator && !isAdmin) {
      return <Navigate to="/" replace />;
    }
  }
  
  return <>{children}</>;
};
```

### components/layout/LibraryLayout.tsx

```
// src/components/layout/LibraryLayout.tsx
import { View, Flex, Button } from '@aws-amplify/ui-react';
import { Outlet, Link, useLocation } from 'react-router-dom';
import { NavigationHeader } from './navigation-header';
import { BreadcrumbNav } from '../common/BreadcrumbNav';

export const LibraryLayout = () => {
  const location = useLocation();

  // パンくずリストの生成
  const getBreadcrumbItems = () => {
    const paths = location.pathname.split('/').filter(Boolean);
    return [
      { label: 'Library', path: '/library' },
      ...paths.slice(1).map((path, index) => ({
        label: path.charAt(0).toUpperCase() + path.slice(1),
        path: '/' + paths.slice(0, index + 2).join('/')
      }))
    ];
  };

  return (
    <Flex direction="column" height="100vh" width="100vw">
      <View
        position="fixed"
        top="0"
        left="0"
        right="0"
        style={{ 
          zIndex: 1000,
          borderBottom: '1px solid var(--amplify-colors-border-primary)',
          backgroundColor: 'var(--amplify-colors-background-primary)'
        }}
      >
        <NavigationHeader />
      </View>

      <View height="60px" />
      
      <BreadcrumbNav items={getBreadcrumbItems()} />

      <View
        as="main"
        flex="1"
        overflow="auto"
        backgroundColor="background.secondary"
        padding={{ base: 'medium', large: 'large' }}
        style={{
          background: `
            linear-gradient(rgba(0,0,0,0.02) 1px, transparent 1px),
            linear-gradient(90deg, rgba(0,0,0,0.02) 1px, transparent 1px)
          `,
          backgroundSize: '20px 20px'
        }}
      >
        <View
          maxWidth="1200px"
          margin="0 auto"
          padding={{ base: 'medium', large: 'large' }}
          style={{
            backgroundColor: 'var(--amplify-colors-background-primary)',
            borderRadius: 'var(--amplify-radii-medium)',
            boxShadow: 'var(--amplify-shadows-small)'
          }}
        >
          <Outlet />
        </View>
      </View>

      <View
        as="footer"
        backgroundColor="background.primary"
        padding="small"
        style={{
          borderTop: '1px solid var(--amplify-colors-border-primary)'
        }}
      >
        <Flex
          direction="row"
          alignItems="center"
          justifyContent="center"
          gap="small"
          height="40px"
        >
          <Button
            as={Link}
            to="/library/mainstory"
            variation="link"
            size="small"
          >
            メインストーリー
          </Button>
          <View
            backgroundColor="border.primary"
            width="1px"
            height="20px"
            margin="0 8px"
          />
          <Button
            as={Link}
            to="/library/sidestory"
            variation="link"
            size="small"
          >
            サイドストーリー
          </Button>
        </Flex>
      </View>
    </Flex>
  );
};
```

### components/layout/AuthLayout.tsx

```
// components/layout/AuthLayout.tsx
import { Outlet, Navigate } from 'react-router-dom';
import { View } from '@aws-amplify/ui-react';
import { NavigationHeader } from './navigation-header';

// 旧: import { useAuth } from '../auth/AuthContext';
import { useSession } from '../../contexts/SessionContext';

export const AuthLayout = () => {
  // 旧: const { isAuthenticated } = useAuth();
  const { isSignedIn } = useSession();

  // もしサインイン済みならトップへリダイレクト
  if (isSignedIn) {
    return <Navigate to="/" replace />;
  }

  return (
    <View>
      <NavigationHeader />
      <View
        padding="medium"
        style={{
          backgroundColor: 'var(--amplify-colors-background-secondary)',
          minHeight: 'calc(100vh - var(--header-height))'
        }}
      >
        <View 
          maxWidth="400px"
          margin="0 auto"
          padding="medium"
          backgroundColor="background.primary"
          style={{
            borderRadius: 'var(--amplify-radii-medium)',
            boxShadow: 'var(--amplify-shadows-medium)'
          }}
        >
          <Outlet />
        </View>
      </View>
    </View>
  );
};

```

### components/layout/CallLayout.tsx

```
// src/components/layout/CallLayout.tsx
import { View, Flex,Text } from '@aws-amplify/ui-react';
import { Outlet } from 'react-router-dom';
import { NavigationHeader } from './navigation-header';

export const CallLayout = () => {
  return (
    <Flex direction="column" height="100vh" width="100vw">
      <View
        position="fixed"
        top="0"
        left="0"
        right="0"
        style={{ zIndex: 1000 }}
        backgroundColor="background.primary"
      >
        <NavigationHeader />
      </View>

      <View height="60px" />
      
      <View
        as="main"
        flex="1"
        overflow="auto"
        backgroundColor="background.primary"
        padding={{ base: 'medium', large: 'large' }}
      >
        <View
          maxWidth="1200px"
          margin="0 auto"
        >
          <Outlet />
        </View>
      </View>

      <View
        as="footer"
        backgroundColor="background.secondary"
        padding="small"
        width="100%"
      >
        <Flex
          direction="row"
          alignItems="center"
          justifyContent="center"
          gap="small"
          height="40px"
        >
          <Text fontSize="small">
            &copy; 2024 Project Niferche
          </Text>
        </Flex>
      </View>
    </Flex>
  );
};
```

### components/layout/LaboratoryLayout.tsx

```
// src/components/layout/LaboratoryLayout.tsx
import { View, Flex, Button } from '@aws-amplify/ui-react';
import { Outlet, Link } from 'react-router-dom';
import { NavigationHeader } from './navigation-header';

export const LaboratoryLayout = () => {
  return (
    <Flex direction="column" height="100vh" width="100vw">
      <View
        position="fixed"
        top="0"
        left="0"
        right="0"
        style={{ zIndex: 1000 }}
        backgroundColor="background.secondary"
      >
        <NavigationHeader />
      </View>

      <View height="60px" />

      <View
        as="main"
        flex="1"
        overflow="auto"
        backgroundColor="background.secondary"
        padding={{ base: 'medium', large: 'large' }}
      >
        <Outlet />
      </View>

      <View
        as="footer"
        backgroundColor="background.secondary"
        padding="small"
        width="100%"
      >
        <Flex
          direction="row"
          alignItems="center"
          justifyContent="center"
          gap="small"
          height="40px"
        >
          <View fontSize="small">
            &copy; 2024 Project Niferche. All rights reserved.
          </View>
          <View
            backgroundColor="border.primary"
            width="1px"
            height="20px"
            margin="0 8px"
          />
          {/* 修正: "/niferche/rights" → "/rights" */}
          <Button
            as={Link}
            to="/rights"
            variation="link"
            size="small"
            padding="0"
          >
            権利情報
          </Button>
          <Button
            as={Link}
            to="/terms"
            variation="link"
            size="small"
            padding="0"
          >
            利用規約
          </Button>
        </Flex>
      </View>
    </Flex>
  );
};

```

### components/layout/MainLayout.tsx

```
// src/components/layout/MainLayout.tsx
import { View, Flex, Button } from '@aws-amplify/ui-react';
import { NavigationHeader } from './navigation-header';
import { Helmet } from 'react-helmet-async';
import { Link, Outlet } from 'react-router-dom';

export const MainLayout = () => {
  return (
    <>
      <Helmet>
        <title>Project Niferche</title>
        <meta
          name="description"
          content="Project Niferche - 創作活動のためのオンラインプラットフォーム"
        />
        <link
          href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap"
          rel="stylesheet"
        />
      </Helmet>

      <Flex direction="column" height="100vh" width="100vw" position="relative">
        <View
          position="fixed"
          top="0"
          left="0"
          right="0"
          style={{ zIndex: 1000 }}
          backgroundColor="background.primary"
          boxShadow="0 2px 4px rgba(0,0,0,0.1)"
        >
          <NavigationHeader />
        </View>

        <View height="60px" />

        <View
          as="main"
          flex="1"
          overflow="auto"
          backgroundColor="background.primary"
          padding={{ base: 'medium', large: 'large' }}
        >
          <Outlet />
        </View>

        <View
          as="footer"
          backgroundColor="background.secondary"
          padding="small"
          width="100%"
        >
          <Flex
            direction="row"
            alignItems="center"
            justifyContent="center"
            gap="small"
            height="40px"
          >
            <View fontSize="small">
              &copy; 2024 Project Niferche. All rights reserved.
            </View>
            <View
              backgroundColor="border.primary"
              width="1px"
              height="20px"
              margin="0 8px"
            />
            {/* 修正: "/niferche/rights" → "/rights" */}
            <Button as={Link} to="/rights" variation="link" size="small" padding="0">
              権利情報
            </Button>
            <Button
              as={Link}
              to="/terms"
              variation="link"
              size="small"
              padding="0"
            >
              利用規約
            </Button>
          </Flex>
        </View>
      </Flex>
    </>
  );
};

```

### components/layout/MaterialsRootLayout.tsx

```
// File: src/components/layout/MaterialsRootLayout.tsx
import { View, Flex, Button } from '@aws-amplify/ui-react';
import { NavigationHeader } from './navigation-header';
import { Link, Outlet } from 'react-router-dom';

/**
 * こちらは「React Router」のRoute Outletを持つルート用レイアウト:
 *   <Route element={<MaterialsRootLayout />}>
 *     <Route path="/materials/about" ... />
 *     ...
 *   </Route>
 *
 * 一方、"components/materials/MaterialsLayout.tsx" は
 * 各ページで「設定資料タイトルや説明」を表示するデザイン用ラッパコンポーネント
 * (props: { title, description, children }) として使うイメージ。
 */

export const MaterialsRootLayout = () => {
  return (
    <Flex direction="column" height="100vh" width="100vw">
      <View
        position="fixed"
        top="0"
        left="0"
        right="0"
        style={{ zIndex: 1000 }}
        backgroundColor="background.tertiary"
      >
        <NavigationHeader />
      </View>

      <View height="60px" />
      
      <View
        as="main"
        flex="1"
        overflow="auto"
        backgroundColor="background.tertiary"
        padding={{ base: 'medium', large: 'large' }}
      >
        <Outlet />
      </View>

      <View
          as="footer"
          backgroundColor="background.secondary"
          padding="small"
          width="100%"
        >
          <Flex
            direction="row"
            alignItems="center"
            justifyContent="center"
            gap="small"
            height="40px"
          >
            <View fontSize="small">
              &copy; 2024 Project Niferche. All rights reserved.
            </View>
            <View
              backgroundColor="border.primary"
              width="1px"
              height="20px"
              margin="0 8px"
            />
            <Button
              as={Link}
              to="/niferche/rights"
              variation="link"
              size="small"
              padding="0"
            >
              権利情報
            </Button>
            <Button
              as={Link}
              to="/terms"
              variation="link"
              size="small"
              padding="0"
            >
              利用規約
            </Button>
          </Flex>
        </View>
    </Flex>
  );
};

```

### components/layout/navigation-header.tsx

```
// src/components/layout/navigation-header.tsx
import { 
  Flex,
  Button,
  Menu,
  MenuItem,
  View,
  useBreakpointValue,
  Divider
} from '@aws-amplify/ui-react';
import { Link, useLocation } from 'react-router-dom';
import { useState } from 'react';
import { useSession } from '../../contexts/SessionContext';
import { UserMenu } from '../user/UserMenu';

// ナビゲーション項目の型定義
interface NavItem {
  label: string;
  path: string;
  children?: NavItem[];
}

// サンプル: ナビゲーション構造
const navigation: NavItem[] = [
  {
    label: 'Call',
    path: '/call',
    children: [
      { label: 'はじめに', path: '/call/about' },
      { label: '理念', path: '/call/philosophy' },
      { label: 'お知らせ', path: '/call/news' }
    ]
  },
  {
    label: 'Library',
    path: '/library',
    children: [
      { label: 'メインストーリー', path: '/library/mainstory' },
      { label: 'サイドストーリー', path: '/library/sidestory' },
    ]
  },
  {
    label: 'Laboratory',
    path: '/laboratory',
    children: [
      { label: '研究概要', path: '/laboratory/about' },
      { label: 'アイデア観測', path: '/laboratory/observation' },
      { label: '研究アーカイブ', path: '/laboratory/archive' },
      { label: '施設案内', path: '/laboratory/guide' }
    ]
  },
  {
    label: 'Materials',
    path: '/materials',
    children: [
      { label: '資料室', path: '/materials/about' },
      { label: 'Common', path: '/materials/common' },
      { label: 'Quxe', path: '/materials/quxe' },
      { label: 'Hodemei', path: '/materials/hodemei' },
      { label: 'Alsarejia', path: '/materials/alsarejia' }
    ]
  },
  {
    label: 'Gallery',
    path: '/gallery'
  }
];

export const NavigationHeader = () => {
  const [isOpen, setIsOpen] = useState(false);
  const location = useLocation();
  const { isSignedIn, logout, user } = useSession();
  const isMobile = useBreakpointValue({ base: true, medium: false });

  const isActive = (path: string) => {
    return location.pathname.startsWith(path);
  };

  // ▼ モバイル用メニューItem（サブメニュー展開）
  const MobileMenuItem = ({ item }: { item: NavItem }) => {
    const [isSubMenuOpen, setIsSubMenuOpen] = useState(false);
    
    return (
      <View width="100%">
        {item.children ? (
          <View width="100%">
            <Button
              width="100%"
              variation="link"
              onClick={() => setIsSubMenuOpen(!isSubMenuOpen)}
              backgroundColor={isActive(item.path) ? "background.secondary" : "transparent"}
            >
              {item.label}
            </Button>
            {isSubMenuOpen && (
              <View paddingLeft="medium">
                {item.children.map((child) => (
                  <Link
                    key={child.path}
                    to={child.path}
                    style={{ textDecoration: 'none', width: '100%' }}
                    onClick={() => setIsOpen(false)}
                  >
                    <Button
                      width="100%"
                      variation="link"
                      backgroundColor={isActive(child.path) ? "background.secondary" : "transparent"}
                    >
                      {child.label}
                    </Button>
                  </Link>
                ))}
              </View>
            )}
          </View>
        ) : (
          <Link
            to={item.path}
            style={{ textDecoration: 'none', width: '100%' }}
            onClick={() => setIsOpen(false)}
          >
            <Button
              width="100%"
              variation="link"
              backgroundColor={isActive(item.path) ? "background.secondary" : "transparent"}
            >
              {item.label}
            </Button>
          </Link>
        )}
      </View>
    );
  };

  // ▼ PC用のドロップダウンメニューItem
  const DesktopMenuItem = ({ item }: { item: NavItem }) => {
    if (item.children) {
      return (
        <Menu 
          key={item.path}
          trigger={
            <Button 
              variation="link"
              backgroundColor={isActive(item.path) ? "background.secondary" : "transparent"}
            >
              {item.label}
            </Button>
          }
        >
          {item.children.map((child) => (
            <MenuItem 
              key={child.path}
              backgroundColor={isActive(child.path) ? "background.secondary" : "transparent"}
            >
              <Link 
                to={child.path} 
                style={{ textDecoration: 'none', color: 'inherit', width: '100%' }}
              >
                {child.label}
              </Link>
            </MenuItem>
          ))}
        </Menu>
      );
    }

    return (
      <Link 
        key={item.path} 
        to={item.path} 
        style={{ textDecoration: 'none' }}
      >
        <Button 
          variation="link"
          backgroundColor={isActive(item.path) ? "background.secondary" : "transparent"}
        >
          {item.label}
        </Button>
      </Link>
    );
  };

  // ▼ モバイルでログイン済みの場合のメニュー追記例
  const AuthenticatedMobileMenu = () => (
    <>
      <Divider />
      <Link to="/profile" style={{ textDecoration: 'none', width: '100%' }}>
        <Button width="100%" variation="link">プロフィール</Button>
      </Link>
      <Link to="/favorites" style={{ textDecoration: 'none', width: '100%' }}>
        <Button width="100%" variation="link">お気に入り</Button>
      </Link>
      {user?.attributes?.['custom:role'] === 'admin' && (
        <Link to="/admin" style={{ textDecoration: 'none', width: '100%' }}>
          <Button width="100%" variation="link">管理画面</Button>
        </Link>
      )}
      <Button width="100%" variation="link" onClick={logout}>
        ログアウト
      </Button>
    </>
  );

  return (
    <View
      backgroundColor="background.primary"
      borderColor="border.primary"
      position="sticky"
      top={0}
      style={{ 
        zIndex: 100,
        height: isMobile ? '50px' : 'var(--header-height)',
        borderBottom: '1px solid var(--amplify-colors-border-primary)'
      }}
    >
      <Flex
        direction="row"
        padding={isMobile ? "0.5rem" : "1rem"}
        justifyContent="space-between"
        alignItems="center"
        maxWidth="1200px"
        margin="0 auto"
      >
        <Link to="/" style={{ textDecoration: 'none' }}>
          <span style={{ 
            color: 'var(--amplify-colors-font-primary)', 
            fontWeight: 'bold',
            fontSize: isMobile ? '1rem' : '1.2rem' 
          }}>
            Project Niferche
          </span>
        </Link>

        {isMobile ? (
          <>
            <Button
              size="small"
              variation="link"
              onClick={() => setIsOpen(!isOpen)}
              style={{
                padding: '0.5rem',
                minWidth: 'auto'
              }}
            >
              ☰
            </Button>
            {isOpen && (
              <View
                position="fixed"
                top="50px"
                left="0"
                right="0"
                bottom="0"
                backgroundColor="background.primary"
                padding="1rem"
                style={{
                  overflowY: 'auto',
                  zIndex: 1000
                }}
              >
                <Flex direction="column" gap="0.5rem">
                  {navigation.map((item) => (
                    <MobileMenuItem key={item.path} item={item} />
                  ))}
                  {isSignedIn ? (
                    <AuthenticatedMobileMenu />
                  ) : (
                    <>
                      <Divider />
                      <Link to="/auth/signin" style={{ textDecoration: 'none', width: '100%' }}>
                        <Button width="100%" variation="primary">ログイン</Button>
                      </Link>
                    </>
                  )}
                </Flex>
              </View>
            )}
          </>
        ) : (
          <Flex direction="row" gap="1rem" alignItems="center">
            {navigation.map((item) => (
              <DesktopMenuItem key={item.path} item={item} />
            ))}
            {isSignedIn ? (
              <UserMenu />
            ) : (
              <Button
                as={Link}
                to="/auth/signin"
                variation="primary"
              >
                ログイン
              </Button>
            )}
          </Flex>
        )}
      </Flex>
    </View>
  );
};
```

### components/content/StoryViewer.tsx

```
// src/components/content/StoryViewer.tsx
import React, { useState, useEffect } from 'react';
import { View, Heading, Text, Button, Flex, Loader, Alert } from '@aws-amplify/ui-react';
import { MockStorageService } from '../../services/mockStorage';

interface StoryViewerProps {
 storyPath: string;
 currentChapter: number;
 totalChapters?: number;
 onChapterChange?: (chapter: number) => void;
 author?: {
   name: string;
   showAuthor: boolean;
 };
 metadata?: {
   title?: string;
   category?: string;
   reference?: string;
 };
}

export const StoryViewer: React.FC<StoryViewerProps> = ({
 storyPath,
 currentChapter,
 totalChapters = 1,
 onChapterChange,
 author,
 metadata
}) => {
 const [content, setContent] = useState<string>('');
 const [loading, setLoading] = useState(true);
 const [error, setError] = useState<string | null>(null);

 useEffect(() => {
   const loadContent = async () => {
     setLoading(true);
     setError(null);
     try {
       const text = await MockStorageService.getText(
         `${storyPath}/chapter${currentChapter}.txt`
       );
       setContent(text);
     } catch (error) {
       console.error('Error loading story content:', error);
       setError('コンテンツの読み込みに失敗しました');
       setContent('');
     } finally {
       setLoading(false);
     }
   };

   loadContent();
 }, [storyPath, currentChapter]);

 return (
   <View className="story-viewer" padding="medium">
     <Flex direction="column" gap="medium">
       {metadata?.title && (
         <Heading level={1}>{metadata.title}</Heading>
       )}
       
       {metadata?.category && metadata?.reference && (
         <Flex justifyContent="space-between" alignItems="center">
           <Text variation="tertiary">{metadata.category}</Text>
           <Text variation="tertiary">Reference: {metadata.reference}</Text>
         </Flex>
       )}

       <Heading level={2}>Chapter {currentChapter}</Heading>
       
       {author?.showAuthor && (
         <Text variation="tertiary">Author: {author.name}</Text>
       )}

       {error && (
         <Alert variation="error">
           {error}
         </Alert>
       )}
       
       <View className="story-content" padding="medium" backgroundColor="white">
         {loading ? (
           <Flex justifyContent="center" padding="medium">
             <Loader size="large" />
           </Flex>
         ) : (
           <Text
             whiteSpace="pre-wrap"
             style={{ lineHeight: '1.6' }}
           >
             {content}
           </Text>
         )}
       </View>

       <Flex justifyContent="space-between" marginTop="large">
         <Button
           onClick={() => onChapterChange?.(currentChapter - 1)}
           disabled={currentChapter <= 1 || loading}
           variation="link"
         >
           前の章へ
         </Button>
         
         <Text variation="tertiary">
           {currentChapter} / {totalChapters}
         </Text>
         
         <Button
           onClick={() => onChapterChange?.(currentChapter + 1)}
           disabled={currentChapter >= totalChapters || loading}
           variation="link"
         >
           次の章へ
         </Button>
       </Flex>
     </Flex>
   </View>
 );
};
```

### components/content/ContentDisplay.tsx

```
import { useEffect, useState } from 'react';
import { Card, Image, Text, Heading, Flex, Button, View, Loader } from '@aws-amplify/ui-react';
import { MockStorageService } from '../../services/mockStorage';

interface ContentDisplayProps {
  path: string;
  type: 'image' | 'text' | 'novel';
  title?: string;
  description?: string;
  fallbackImage?: string;
  pagination?: {
    currentPage: number;
    onPageChange: (page: number) => void;
    totalPages?: number;
  };
}

export const ContentDisplay: React.FC<ContentDisplayProps> = ({
  path,
  type,
  title,
  description,
  fallbackImage = '/images/fallback.jpg',
  pagination
}) => {
  const [content, setContent] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [imageLoadError, setImageLoadError] = useState(false);

  useEffect(() => {
    let isMounted = true;

    const loadContent = async () => {
      try {
        setLoading(true);
        setError(null);
        setImageLoadError(false);

        if (type === 'image') {
          const url = await MockStorageService.getImage(path);
          if (isMounted) setContent(url);
        } else {
          const text = await MockStorageService.getText(path);
          if (isMounted) setContent(text);
        }
      } catch (err) {
        if (isMounted) {
          setError('コンテンツの読み込みに失敗しました');
          console.error('Error loading content:', err);
        }
      } finally {
        if (isMounted) setLoading(false);
      }
    };

    loadContent();

    return () => {
      isMounted = false;
    };
  }, [path, type]);

  const handleImageError = () => {
    setImageLoadError(true);
    console.warn(`Image load failed for path: ${path}`);
  };

  if (loading) {
    return (
      <Card variation="elevated">
        <Flex justifyContent="center" padding="medium">
          <Loader size="large" />
        </Flex>
      </Card>
    );
  }

  return (
    <Card variation="elevated">
      <Flex direction="column" gap="medium">
        {title && <Heading level={3}>{title}</Heading>}
        {description && <Text>{description}</Text>}
        
        {type === 'image' && (
          <Image
            src={imageLoadError ? fallbackImage : (content || fallbackImage)}
            alt={title || 'Content image'}
            objectFit="cover"
            maxHeight="500px"
            onError={handleImageError}
          />
        )}
        
        {(type === 'text' || type === 'novel') && content && (
          <View padding="medium">
            <Text whiteSpace="pre-wrap">{content}</Text>
          </View>
        )}

        {error && (
          <View backgroundColor="red.10" padding="medium" borderRadius="medium">
            <Text color="red.80">{error}</Text>
          </View>
        )}

        {pagination && (
          <Flex justifyContent="center" gap="small">
            <Button 
              onClick={() => pagination.onPageChange(pagination.currentPage - 1)}
              isDisabled={pagination.currentPage <= 1}
              variation="link"
            >
              前へ
            </Button>
            <Text>
              {pagination.currentPage} / {pagination.totalPages ?? '?'}
            </Text>
            <Button 
              onClick={() => pagination.onPageChange(pagination.currentPage + 1)}
              isDisabled={pagination.totalPages ? pagination.currentPage >= pagination.totalPages : false}
              variation="link"
            >
              次へ
            </Button>
          </Flex>
        )}
      </Flex>
    </Card>
  );
};
```

### components/content/LazyContent.tsx

```
// src/components/content/LazyContent.tsx
import { Suspense } from 'react';
import { View, Loader } from '@aws-amplify/ui-react';

export const LazyContent = ({ children }: { children: React.ReactNode }) => {
  return (
    <Suspense 
      fallback={
        <View padding="2rem" textAlign="center">
          <Loader size="large" />
        </View>
      }
    >
      {children}
    </Suspense>
  );
};
```

### components/user/UserMenu.tsx

```
// src/components/user/UserMenu.tsx
import { 
  Menu, 
  MenuItem, 
  Button, 
  Badge, 
  Flex 
} from '@aws-amplify/ui-react';
import { Link } from 'react-router-dom';
import { useSession } from '../../contexts/SessionContext';

export const UserMenu = () => {
  const { user, logout } = useSession();

  return (
    <Menu 
      trigger={
        <Button variation="menu">
          <Flex alignItems="center" gap="small">
            {user?.username}
            {user?.attributes?.['custom:role'] === 'admin' && (
              <Badge variation="info">管理者</Badge>
            )}
          </Flex>
        </Button>
      }
    >
      <MenuItem>
        <Link to="/profile" style={{ textDecoration: 'none', color: 'inherit' }}>
          プロフィール
        </Link>
      </MenuItem>
      <MenuItem>
        <Link to="/favorites" style={{ textDecoration: 'none', color: 'inherit' }}>
          お気に入り
        </Link>
      </MenuItem>
      {user?.attributes?.['custom:role'] === 'admin' && (
        <MenuItem>
          <Link to="/admin" style={{ textDecoration: 'none', color: 'inherit' }}>
            管理画面
          </Link>
        </MenuItem>
      )}
      <MenuItem onClick={logout}>
        ログアウト
      </MenuItem>
    </Menu>
  );
};
```

### components/common/SkeletonList.tsx

```
// src/components/common/SkeletonList.tsx
import React from 'react';
import { Flex, View } from '@aws-amplify/ui-react';

interface SkeletonListProps {
  count?: number; // 生成するスケルトン数
}

export const SkeletonList: React.FC<SkeletonListProps> = ({ count = 5 }) => {
  return (
    <Flex direction="column" gap="small">
      {Array.from({ length: count }).map((_, i) => (
        <View
          key={i}
          backgroundColor="var(--amplify-colors-background-tertiary)"
          height="80px"
          borderRadius="small"
          // アニメーション例
          style={{ animation: 'skeleton-loading 1s infinite alternate' }}
        />
      ))}

      <style>
        {`
          @keyframes skeleton-loading {
            0% {
              opacity: 0.5;
            }
            100% {
              opacity: 1;
            }
          }
        `}
      </style>
    </Flex>
  );
};

```

### components/common/LibraryListViewItem.tsx

```
// src/components/common/LibraryListViewItem.tsx

import { Flex, Text, Badge, Button } from '@aws-amplify/ui-react';
import { useNavigate } from 'react-router-dom';

interface LibraryListViewItemProps {
  id: string;
  title: string;
  description?: string;
  imagePath?: string;
  category?: string; // 例: "MAGIC", "THEORY"など
  tags?: string[];
  isAvailable?: boolean;
  reference?: string;
  linkTo?: string;
  onClick?: () => void;
}

/**
 * リスト表示用のアイテム。Cardではなく行単位のUIにしているイメージ。
 * 画像サムネイルを左、メイン情報を中央、アクションを右に並べるなどの実装も可。
 */
export const LibraryListViewItem: React.FC<LibraryListViewItemProps> = ({
  id,
  title,
  description,
  isAvailable = true,
  reference,
  linkTo,
  onClick,
  tags = [],
  category,
}) => {
  const navigate = useNavigate();

  const handleClick = () => {
    if (!isAvailable) {
      alert('このコンテンツは現在準備中です');
      return;
    }
    if (onClick) {
      onClick();
    }
    if (linkTo) {
      navigate(linkTo);
    }
  };

  return (
    <Flex
      key={id}
      direction="row"
      gap="small"
      alignItems="center"
      justifyContent="space-between"
      padding="1rem"
      backgroundColor="var(--amplify-colors-background-primary)"
      borderRadius="small"
      style={{ cursor: isAvailable ? 'pointer' : 'default' }}
      onClick={handleClick}
    >
      <Flex direction="column" gap="xsmall">
        <Text fontWeight="bold">{title}</Text>
        {description && (
          <Text
            fontSize="small"
            color="font.secondary"
            style={{
              overflow: 'hidden',
              textOverflow: 'ellipsis',
              display: '-webkit-box',
              WebkitLineClamp: 2,
              WebkitBoxOrient: 'vertical',
              maxWidth: '500px',
            }}
          >
            {description}
          </Text>
        )}

        <Flex gap="xsmall" wrap="wrap">
          {category && (
            <Badge variation="info">{category}</Badge>
          )}
          {tags.map((tag) => (
            <Badge variation="warning" key={tag}>
              {tag}
            </Badge>
          ))}
        </Flex>
      </Flex>

      <Flex direction="row" gap="small" alignItems="center">
        {reference && (
          <Text fontSize="xsmall" color="font.tertiary">
            {reference}
          </Text>
        )}
        <Badge variation={isAvailable ? 'success' : 'error'}>
          {isAvailable ? '利用可' : '準備中'}
        </Badge>

        {/* もっと細かいアクションが必要なら、Buttonを置くなど */}
        {linkTo && (
          <Button size="small" variation="link">
            詳細へ
          </Button>
        )}
      </Flex>
    </Flex>
  );
};

```

### components/common/Meta.tsx

```
// src/components/common/Meta.tsx
import { Helmet } from 'react-helmet-async';

interface MetaProps {
  title: string;
  description: string;
  path: string;
  type?: 'website' | 'article';
  image?: string;
}

export const Meta = ({
  title,
  description,
  path,
  type = 'website',
  image = '/og-default.png'  // デフォルトのOG画像
}: MetaProps) => {
  const siteUrl = 'https://niferche.com';
  const fullUrl = `${siteUrl}${path}`;
  const fullTitle = `${title} | Project Niferche`;

  return (
    <Helmet>
      {/* 基本メタデータ */}
      <title>{fullTitle}</title>
      <meta name="description" content={description} />
      
      {/* OGP */}
      <meta property="og:title" content={fullTitle} />
      <meta property="og:description" content={description} />
      <meta property="og:url" content={fullUrl} />
      <meta property="og:type" content={type} />
      <meta property="og:image" content={`${siteUrl}${image}`} />
      
      {/* Twitter Card */}
      <meta name="twitter:card" content="summary_large_image" />
      <meta name="twitter:title" content={fullTitle} />
      <meta name="twitter:description" content={description} />
      <meta name="twitter:image" content={`${siteUrl}${image}`} />
      
      {/* 構造化データ */}
      <script type="application/ld+json">
        {JSON.stringify({
          '@context': 'https://schema.org',
          '@type': type === 'article' ? 'Article' : 'WebSite',
          name: title,
          description: description,
          url: fullUrl
        })}
      </script>
    </Helmet>
  );
};

```

### components/common/LoadingState.css

```
.loading-spinner-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 1rem;
  gap: 0.75rem;
}

.loading-spinner-container.full-page {
  min-height: 60vh;
  width: 100%;
}

.loading-spinner-container.overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background-color: rgba(255, 255, 255, 0.8);
  z-index: 10;
  backdrop-filter: blur(2px);
}

.loading-spinner-small {
  --loader-size: 1.5rem;
}

.loading-spinner-medium {
  --loader-size: 2.5rem;
}

.loading-spinner-large {
  --loader-size: 3.5rem;
  animation-duration: 1.2s;
}

.loading-message {
  font-size: 0.9rem;
  color: #666;
  text-align: center;
  max-width: 24rem;
  animation: fadeIn 0.5s ease-in-out;
}

@keyframes fadeIn {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

/* スケルトンローディング関連のスタイル */
.skeleton-item {
  background: linear-gradient(90deg, #f0f0f0 25%, #e0e0e0 50%, #f0f0f0 75%);
  background-size: 200% 100%;
  animation: shimmer 1.5s infinite;
  border-radius: 4px;
}

@keyframes shimmer {
  0% {
    background-position: -200% 0;
  }
  100% {
    background-position: 200% 0;
  }
}
```

### components/common/ContentCard.tsx

```
import { Card, Flex, Text, Heading, Image, View } from '@aws-amplify/ui-react';
import { useNavigate } from 'react-router-dom';
import './ContentCard.css';

interface ContentCardProps {
  title: string;
  description?: string;
  imagePath?: string;
  linkTo?: string;
  onClick?: () => void;
  size?: 'small' | 'medium' | 'large';
  variant?: 'story' | 'material' | 'info';
  footer?: React.ReactNode;
}

export const ContentCard: React.FC<ContentCardProps> = ({
  title,
  description,
  imagePath,
  linkTo,
  onClick,
  size = 'medium',
  variant = 'story',
  footer
}) => {
  const navigate = useNavigate();

  const handleClick = () => {
    if (onClick) {
      onClick();
    }
    if (linkTo) {
      navigate(linkTo);
    }
  };

  // サイズに基づく設定
  const getCardStyles = () => {
    switch (size) {
      case 'small':
        return 'content-card-small';
      case 'large':
        return 'content-card-large';
      default:
        return 'content-card-medium';
    }
  };

  // バリアントに基づく設定
  const getVariantStyles = () => {
    switch (variant) {
      case 'material':
        return 'content-card-material';
      case 'info':
        return 'content-card-info';
      default:
        return 'content-card-story';
    }
  };

  return (
    <Card
      variation="elevated"
      padding="medium"
      borderRadius="medium"
      onClick={linkTo || onClick ? handleClick : undefined}
      className={`ContentCard ${getCardStyles()} ${getVariantStyles()} ${(linkTo || onClick) ? 'clickable' : ''}`}
      aria-label={title}
    >
      <Flex direction="column" gap="medium" className="content-card-container">
        {imagePath && (
          <div className="content-card-image-container">
            <Image
              src={imagePath}
              alt={title}
              objectFit="cover"
              width="100%"
              height="auto"
              className="content-card-image"
              borderRadius="medium"
              loading="lazy"
              onError={(e) => {
                // オプション: 画像読み込みエラー時のフォールバック
                if (e && typeof e !== 'string' && 'currentTarget' in e) {
                  (e.currentTarget as HTMLImageElement).src = '/images/fallback.jpg';
                }
              }}
            />
          </div>
        )}
        
        <View className="content-card-content">
          <Heading level={3} className="content-card-title">{title}</Heading>
          
          {description && (
            <Text className="content-card-description">
              {description.length > 120 ? `${description.substring(0, 120)}...` : description}
            </Text>
          )}
        </View>
        
        {footer && (
          <View className="content-card-footer">
            {footer}
          </View>
        )}
      </Flex>
    </Card>
  );
};
```

### components/common/ContentSection.tsx

```
// src/components/common/ContentSection.tsx
import { View, Heading, Text, Flex } from '@aws-amplify/ui-react';

interface ContentSectionProps {
  title: string;
  description?: string;
  variant?: 'default' | 'laboratory' | 'materials';
  children: React.ReactNode;
}

export const ContentSection = ({ 
  title, 
  description, 
  variant = 'default',
  children 
}: ContentSectionProps) => {
  const sectionStyles = {
    default: {
      padding: '2rem',
      backgroundColor: 'background.primary',
      borderRadius: '8px',
    },
    laboratory: {
      padding: '2rem',
      backgroundColor: 'rgba(30, 41, 59, 0.8)',
      borderRadius: '4px',
      border: '1px solid var(--amplify-colors-border-primary)',
    },
    materials: {
      padding: '1.5rem',
      backgroundColor: 'background.secondary',
      borderRadius: '2px',
    }
  };

  return (
    <View
      style={sectionStyles[variant]}
      marginBottom="2rem"
    >
      <Flex direction="column" gap="medium">
        <Heading level={2}>{title}</Heading>
        {description && <Text>{description}</Text>}
        {children}
      </Flex>
    </View>
  );
};
```

### components/common/LoadingSpinner.tsx

```
// src/components/common/LoadingSpinner.tsx
import { Flex, Loader, Text } from '@aws-amplify/ui-react';
import './LoadingState.css';

interface LoadingSpinnerProps {
  message?: string;
  size?: 'small' | 'medium' | 'large';
  fullPage?: boolean;
  overlay?: boolean;
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({ 
  message, 
  size = 'medium', 
  fullPage = false,
  overlay = false
}) => {
  const containerClasses = [
    'loading-spinner-container',
    fullPage ? 'full-page' : '',
    overlay ? 'overlay' : ''
  ].filter(Boolean).join(' ');

  return (
    <Flex 
      direction="column" 
      alignItems="center" 
      justifyContent="center"
      gap="small" 
      padding="1rem"
      className={containerClasses}
    >
      <Loader 
        variation="linear"
        className={`loading-spinner-${size}`}
        aria-label="読み込み中"
      />
      {message && (
        <Text 
          className="loading-message"
          aria-live="polite"
        >
          {message}
        </Text>
      )}
    </Flex>
  );
};

```

### components/common/ErrorAlert.tsx

```
// src/components/common/ErrorAlert.tsx
import React from 'react';
import { Alert } from '@aws-amplify/ui-react';

interface ErrorAlertProps {
  errorMessage: string;
  onDismiss?: () => void;
}

export const ErrorAlert: React.FC<ErrorAlertProps> = ({
  errorMessage,
  onDismiss,
}) => {
  return (
    <Alert
      variation="error"
      isDismissible
      onDismiss={onDismiss}
    >
      {errorMessage}
    </Alert>
  );
};

```

### components/common/AdvancedFilterPanel.tsx

```
// src/components/common/AdvancedFilterPanel.tsx

import React, { useState, useEffect } from 'react';
import { 
  Flex,
  SelectField,
  SearchField,
  Button,
  Text,
  Badge,
  View
} from '@aws-amplify/ui-react';

interface FilterCondition {
  keyword: string;
  world: string;
  tags: string[];
}

interface AdvancedFilterPanelProps {
  availableTags: string[];   // 外部からタグ一覧を渡す
  availableWorlds: string[]; // 外部から世界観一覧を渡す
  onChange: (filter: FilterCondition) => void;
}

export const AdvancedFilterPanel: React.FC<AdvancedFilterPanelProps> = ({
  availableTags,
  availableWorlds,
  onChange,
}) => {
  const [keyword, setKeyword] = useState('');
  const [world, setWorld] = useState('all');
  const [selectedTags, setSelectedTags] = useState<string[]>([]);

  // フィルタ条件が変更されるたびに親コンポーネントへ通知
  useEffect(() => {
    onChange({
      keyword,
      world,
      tags: selectedTags,
    });
  }, [keyword, world, selectedTags, onChange]);

  const handleTagToggle = (tag: string) => {
    setSelectedTags((prev) => {
      if (prev.includes(tag)) {
        return prev.filter((t) => t !== tag);
      } else {
        return [...prev, tag];
      }
    });
  };

  const handleReset = () => {
    setKeyword('');
    setWorld('all');
    setSelectedTags([]);
  };

  return (
    <Flex 
      direction="column" 
      gap="small"
      padding="1rem"
      border="1px solid var(--amplify-colors-border-primary)"
      borderRadius="0.5rem"
    >
      <SearchField
        label="キーワード検索"
        placeholder="キーワードを入力"
        value={keyword}
        onChange={(e) => setKeyword(e.target.value)}
      />

      <SelectField
        label="世界観"
        value={world}
        onChange={(e) => setWorld(e.target.value)}
      >
        <option value="all">すべて</option>
        {availableWorlds.map((w) => (
          <option value={w} key={w}>{w}</option>
        ))}
      </SelectField>

      <Text>タグで絞り込み:</Text>
      <Flex gap="small" wrap="wrap">
        {availableTags.map((tag) => (
          <Badge
          key={tag}
          variation={selectedTags.includes(tag) ? 'info' : 'warning'} // 例としてwarningを未選択時に
          style={{ cursor: 'pointer' }}
          onClick={() => handleTagToggle(tag)}
        >
          {tag}
        </Badge>
        ))}
      </Flex>

      {selectedTags.length > 0 && (
        <View>
          <Text>選択中のタグ:</Text>
          <Flex gap="xsmall" wrap="wrap">
            {selectedTags.map((tag) => (
              <Badge 
                key={`selected-${tag}`} 
                variation="info"
                onClick={() => handleTagToggle(tag)}
                style={{ cursor: 'pointer' }}
              >
                {tag} x
              </Badge>
            ))}
          </Flex>
        </View>
      )}

      <Flex justifyContent="flex-end">
        <Button onClick={handleReset} size="small" variation="link">
          リセット
        </Button>
      </Flex>
    </Flex>
  );
};

```

### components/common/DetailModal.tsx

```
// src/components/common/DetailModal.tsx
import {
  Card,
  Heading,
  Text,
  Image,
  Flex,
  Button,
  View,
  Badge,
  useTheme,
  Divider,
} from '@aws-amplify/ui-react';

/**
 * ▼ Amplify UI の Badge は variation に
 *    'info' | 'error' | 'warning' | 'success'
 *  のみを指定可能です。
 */
type EntityType = 'facility' | 'research' | 'idea' | 'story' | 'material';

// あるいは、今後さらに追加したいなら下記のようにまとめてもOK
// export type BadgeVariationType = 'info' | 'error' | 'warning' | 'success';

interface DetailData {
  id: string;
  title: string;
  description: string;
  category: string;
  imagePath?: string;
  details?: {
    title: string;
    content: string;
  }[];
  metadata?: Record<string, string>;
  tags?: string[];
}

interface DetailModalProps {
  isOpen: boolean;
  onClose: () => void;
  data: DetailData;
  entityType: EntityType;  
}

export const DetailModal: React.FC<DetailModalProps> = ({
  isOpen,
  onClose,
  data,
  entityType
}) => {
  const { tokens } = useTheme();

  // ◆ entityType から Badge の variation を決定する関数
  const getBadgeVariation = (type: EntityType) => {
    switch (type) {
      case 'facility':
        return 'success';   // 緑
      case 'research':
        return 'info';      // 青
      case 'idea':
        return 'warning';   // 黄
      case 'story':
        return 'info';      // (お好みで)
      case 'material':
        return 'success';   // (お好みで)
      default:
        return 'info';      // どれにも該当しないとき
    }
  };

  // モーダルの表示/非表示
  if (!isOpen) return null;

  return (
    // ※ `inset="0"` は使えないので top="0" left="0" ... 等で代用
    <View
      position="fixed"
      top="0"
      left="0"
      right="0"
      bottom="0"
      style={{
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
        zIndex: 1000,
      }}
      onClick={onClose}
    >
      <Card
        position="relative"
        maxWidth="800px"
        maxHeight="90vh"
        overflow="auto"
        margin="auto"
        padding={tokens.space.medium}
        backgroundColor={tokens.colors.background.primary}
        style={{
          top: '50%',
          left: '50%',
          transform: 'translate(-50%, -50%)',
        }}
        // カード領域のクリックはモーダルを閉じないよう stopPropagation
        onClick={(e) => e.stopPropagation()}
      >
        <Flex direction="column" gap={tokens.space.medium}>

          {data.imagePath && (
            <Image
              src={data.imagePath}
              alt={data.title}
              width="100%"
              height="300px"
              objectFit="cover"
              borderRadius={tokens.radii.medium}
            />
          )}

          <Flex justifyContent="space-between" alignItems="center">
            <Heading level={2}>{data.title}</Heading>

            {/* Badge の variation に "neutral" や "default" は不可。 */}
            <Badge variation={getBadgeVariation(entityType)}>
              {entityType.charAt(0).toUpperCase() + entityType.slice(1)}
            </Badge>
          </Flex>

          {data.tags && data.tags.length > 0 && (
            <Flex gap="small" wrap="wrap">
              {data.tags.map(tag => (
                <Badge key={tag} variation="info">
                  {tag}
                </Badge>
              ))}
            </Flex>
          )}

          <Text>{data.description}</Text>

          {data.details && data.details.length > 0 && (
            <>
              <Divider />
              {data.details.map((detail, index) => (
                <Flex key={index} direction="column" gap="small">
                  <Heading level={4}>{detail.title}</Heading>
                  <Text>{detail.content}</Text>
                </Flex>
              ))}
            </>
          )}

          {data.metadata && (
            <View
              backgroundColor={tokens.colors.background.secondary}
              padding={tokens.space.medium}
              borderRadius={tokens.radii.medium}
            >
              {Object.entries(data.metadata).map(([key, value]) => (
                <Flex key={key} justifyContent="space-between" padding="xs">
                  <Text fontWeight="bold">{key}:</Text>
                  <Text>{value}</Text>
                </Flex>
              ))}
            </View>
          )}

          <Flex justifyContent="flex-end">
            <Button onClick={onClose}>閉じる</Button>
          </Flex>
        </Flex>
      </Card>
    </View>
  );
};

```

### components/common/ContentCard.css

```
.ContentCard {
  transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
  width: 100%;
  position: relative;
  overflow: hidden;
}

/* クリック可能なカードのスタイル */
.ContentCard.clickable {
  cursor: pointer;
}

.ContentCard.clickable:hover {
  transform: translateY(-4px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.ContentCard.clickable:active {
  transform: translateY(-2px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
}

/* サイズバリエーション */
.content-card-small {
  max-width: 250px;
}

.content-card-medium {
  max-width: 350px;
}

.content-card-large {
  max-width: 500px;
}

/* バリアントスタイル */
.content-card-story {
  border-left: 4px solid #7f56d9;
}

.content-card-material {
  border-left: 4px solid #22c55e;
}

.content-card-info {
  border-left: 4px solid #3b82f6;
}

/* 画像コンテナ */
.content-card-image-container {
  width: 100%;
  position: relative;
  overflow: hidden;
  aspect-ratio: 16 / 9;
  border-radius: 8px;
  margin-bottom: 0.5rem;
}

.content-card-image {
  width: 100%;
  height: 100%;
  object-fit: cover;
  transition: transform 0.3s ease;
}

.ContentCard.clickable:hover .content-card-image {
  transform: scale(1.05);
}

/* コンテンツスタイル */
.content-card-content {
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
  min-height: 60px;
}

.content-card-title {
  font-size: 1.25rem;
  margin-bottom: 0.5rem;
  line-height: 1.4;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 2;
  -webkit-box-orient: vertical;
}

.content-card-description {
  color: #64748b;
  font-size: 0.875rem;
  line-height: 1.6;
  overflow: hidden;
  text-overflow: ellipsis;
  display: -webkit-box;
  -webkit-line-clamp: 3;
  -webkit-box-orient: vertical;
}

.content-card-footer {
  margin-top: 1rem;
  border-top: 1px solid #e2e8f0;
  padding-top: 0.75rem;
}

/* レスポンシブデザイン */
@media (max-width: 768px) {
  .content-card-small,
  .content-card-medium,
  .content-card-large {
    max-width: 100%;
  }
  
  .content-card-title {
    font-size: 1.1rem;
  }
  
  .content-card-image-container {
    aspect-ratio: 16 / 10;
  }
}

@media (max-width: 480px) {
  .content-card-image-container {
    aspect-ratio: 16 / 12;
  }
}
```

### components/common/BreadcrumbNav.tsx

```
// src/components/common/BreadcrumbNav.tsx
import { Flex, Text, Link } from '@aws-amplify/ui-react';

interface BreadcrumbItem {
  label: string;
  path: string;
}

interface BreadcrumbNavProps {
  items: BreadcrumbItem[];
}

export const BreadcrumbNav: React.FC<BreadcrumbNavProps> = ({ items }) => {
  return (
    <Flex gap="small" padding="medium">
      {items.map((item, index) => (
        <Flex key={item.path} gap="small" alignItems="center">
          {index > 0 && <Text color="font.tertiary">/</Text>}
          {index === items.length - 1 ? (
            <Text color="font.secondary">{item.label}</Text>
          ) : (
            <Link href={item.path}>{item.label}</Link>
          )}
        </Flex>
      ))}
    </Flex>
  );
};
```

### components/common/FavoriteButton.tsx

```
// src/components/common/FavoriteButton.tsx
import { Button } from '@aws-amplify/ui-react';
import { useSession } from '../../contexts/SessionContext';
import { useState } from 'react';

interface FavoriteButtonProps {
  contentId: string;
  initialState?: boolean;
  onToggle?: (isFavorite: boolean) => void;
}

export const FavoriteButton = ({ 
  contentId, 
  initialState = false,
  onToggle 
}: FavoriteButtonProps) => {
  const { isSignedIn } = useSession();
  const [isFavorite, setIsFavorite] = useState(initialState);

  const handleFavoriteClick = async () => {
    if (!isSignedIn) {
      alert('ログインが必要です');
      return;
    }

    try {
      const newState = !isFavorite;
      setIsFavorite(newState);
      onToggle?.(newState);
      // TODO: バックエンド連携 (GraphQL mutationなど)
      console.log(`Toggled favorite for contentId=${contentId}, newState=${newState}`);
    } catch (error) {
      console.error('Error toggling favorite:', error);
    }
  };

  return (
    <Button
      onClick={handleFavoriteClick}
      variation="link"
      color={isFavorite ? 'red' : 'gray'}
    >
      {isFavorite ? '★' : '☆'}
    </Button>
  );
};


```

### components/common/ErrorBoundary.tsx

```
// components/common/ErrorBoundary.tsx
import React from 'react';
import { useNavigate } from 'react-router-dom';
import { View, Heading, Text } from '@aws-amplify/ui-react';

interface Props {
  children: React.ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

export class ErrorBoundary extends React.Component<Props, State> {
  public state: State = {
    hasError: false
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      return <ErrorFallback error={this.state.error} />;
    }

    return this.props.children;
  }
}

// エラー表示用のコンポーネント
const ErrorFallback = ({ error }: { error?: Error }) => {
  const navigate = useNavigate();

  React.useEffect(() => {
    // エラーページへリダイレクト
    navigate('/error', { 
      state: { 
        errorMessage: error?.message || 'An unexpected error occurred.'
      }
    });
  }, [error, navigate]);

  // リダイレクト中の表示
  return (
    <View padding="medium" textAlign="center">
      <Heading level={2}>エラーが発生しました</Heading>
      <Text>ページを移動しています...</Text>
    </View>
  );
};
```

### components/badges/BadgeNotification.tsx

```
// File: src/components/badges/BadgeNotification.tsx
import { Alert, Flex, Image, Text } from '@aws-amplify/ui-react';
import { Badge } from '../../types/badges';

interface BadgeNotificationProps {
  badge: Badge;
  onClose: () => void;
}

export const BadgeNotification = ({ badge, onClose }: BadgeNotificationProps) => {
  return (
    <Alert
      variation="info"
      isDismissible={true}
      hasIcon={true}
      onDismiss={onClose}
    >
      <Flex direction="row" alignItems="center" gap="medium">
        <Image
          alt={badge.name}
          src={badge.iconUrl}
          width="32px"
          height="32px"
        />
        <Flex direction="column">
          <Text variation="primary" fontWeight="bold">
            新しいバッジを獲得しました！
          </Text>
          <Text>{badge.name}</Text>
          <Text variation="tertiary" fontSize="small">
            {badge.description}
          </Text>
        </Flex>
      </Flex>
    </Alert>
  );
};
```

### vite-env.d.ts

```
/// <reference types="vite/client" />

```

### theme/index.tsx

```
import { Theme } from '@aws-amplify/ui-react';

export const theme: Theme = {
  name: 'niferche-theme',
  tokens: {
    colors: {
      // 研究所をイメージした洗練された配色
      brand: {
        primary: { value: '#2D3142' },   // メインカラー：深いネイビー
        secondary: { value: '#4F5D75' }, // サブカラー：グレイッシュブルー
        accent: { value: '#7796CB' }     // アクセント：ライトブルー
      },
      background: {
        primary: { value: '#FFFFFF' },   // 白背景
        secondary: { value: '#F7F9FC' }, // うっすらとしたブルーグレー
        tertiary: { value: '#EEF2F6' }   // より濃いブルーグレー
      },
      font: {
        primary: { value: '#2D3142' },   // 濃色文字
        secondary: { value: '#4F5D75' }, // やや薄い文字
        accent: { value: '#7796CB' }     // アクセント文字
      }
    },
    space: {
      small: { value: '0.75rem' },
      medium: { value: '1rem' },
      large: { value: '1.5rem' },
      xl: { value: '2rem' },
      xxl: { value: '3rem' }
    },
    fonts: {
      default: {
        variable: { value: '"Noto Sans JP Variable", sans-serif' },
        static: { value: '"Noto Sans JP", sans-serif' }
      }
    },
    components: {
      card: {
        backgroundColor: { value: '{colors.background.primary}' },
        borderRadius: { value: '8px' },
        boxShadow: { value: '0 2px 4px rgba(45, 49, 66, 0.1)' }
      },
      heading: {
        color: { value: '{colors.font.primary}' }
      },
      text: {
        color: { value: '{colors.font.secondary}' }
      },
      button: {
        primary: {
          backgroundColor: { value: '{colors.brand.primary}' },
          color: { value: 'white' }
        },
        }
      }
    }
  }
;
```

### theme/tokens.tsx

```
// src/theme/tokens.ts
export const tokens = {
  colors: {
    font: {
      primary: { value: '{colors.neutral.100}' },
      secondary: { value: '{colors.neutral.80}' },
      tertiary: { value: '{colors.neutral.60}' }
    },
    background: {
      primary: { value: '{colors.white}' },
      secondary: { value: '{colors.neutral.10}' },
      tertiary: { value: '{colors.neutral.20}' }
    },
    border: {
      primary: { value: '{colors.neutral.20}' },
      secondary: { value: '{colors.neutral.40}' }
    }
  },
  space: {
    small: { value: '0.5rem' },
    medium: { value: '1rem' },
    large: { value: '1.5rem' }
  },
  components: {
    navigation: {
      height: { value: '4rem' },
      fontSize: { value: '1rem' }
    }
  }
};
```

### theme/laboratory.css

```
.amplify-card {
  transition: all 0.3s ease-in-out;
}

.amplify-card:hover {
  transform: translateY(-4px);
  box-shadow: var(--amplify-shadows-medium);
}

.amplify-button {
  transition: all 0.2s ease-in-out;
}

.amplify-button:hover {
  transform: translateY(-2px);
}

.amplify-heading {
  letter-spacing: 0.05em;
  transition: color 0.2s ease-in-out;
}

.amplify-heading:hover {
  color: var(--amplify-colors-font-interactive);
}
```

### theme/components.tsx

```
// src/theme/components.ts
export const components = {
  button: {
    primary: {
      backgroundColor: { value: '{colors.brand.primary}' },
      color: { value: '{colors.white}' }
    }
  },
  menu: {
    backgroundColor: { value: '{colors.background.primary}' },
    borderColor: { value: '{colors.border.primary}' }
  }
};
```

### theme/materialsTheme.tsx

```
// src/theme/materialsTheme.tsx
import { Theme } from '@aws-amplify/ui-react';
import { MaterialsThemeTokens } from '../types/materials';

const themeTokens: MaterialsThemeTokens = {
  colors: {
    background: {
      primary: { value: '#f8f4e9' },
      secondary: { value: '#f5f5f0' },
      tertiary: { value: '#e8e5d5' }
    },
    font: {
      primary: { value: '#2c1810' },
      secondary: { value: '#4a4a4a' },
      tertiary: { value: '#666666' }
    },
    border: {
      primary: { value: '#d4d4c7' },
      secondary: { value: '#bfbfb2' }
    }
  }
};

export const materialsTheme: Theme = {
  name: 'materials-theme',
  tokens: {
    ...themeTokens,
    components: {
      card: {
        backgroundColor: { value: themeTokens.colors.background.secondary.value },
        boxShadow: { value: '2px 2px 4px rgba(0,0,0,0.1)' }
      },
      heading: {
        color: { value: themeTokens.colors.font.primary.value }
      },
      text: {
        color: { value: themeTokens.colors.font.secondary.value }
      }
    },
    fonts: {
      default: {
        variable: { value: 'Georgia, "Times New Roman", serif' },
        static: { value: 'Georgia, "Times New Roman", serif' }
      }
    }
  }
};

export const getThemeTokens = () => themeTokens;
```

### theme/laboratoryTheme.tsx

```
// src/theme/laboratoryTheme.tsx
import { Theme } from '@aws-amplify/ui-react';

export const laboratoryTheme: Theme = {
  name: 'laboratory-theme',
  tokens: {
    colors: {
      background: {
        primary: '#1a1f2e',
        secondary: '#242938',
        tertiary: '#2d334a',
      },
      font: {
        primary: '#e2678a',
        secondary: '#eaeaea',
        tertiary: '#b8b8b8',
        interactive: '#ff8fa3',
      },
      border: {
        primary: '#e2678a',
        secondary: '#2d334a',
      },
      accent: {
        purple: '#9f7aea',
        blue: '#4299e1',
        pink: '#ed64a6'
      }
    },
    components: {
      button: {
        primary: {
          backgroundColor: { value: '#e2678a' },
          color: { value: '#ffffff' },
          // hover状態はスタイルで制御
        },
      },
      card: {
        backgroundColor: { value: '#242938' },
        borderColor: { value: '#2d334a' },
        // hover状態はスタイルで制御
      },
      heading: {
        color: { value: '#e2678a' },
        // その他のスタイルはCSSで制御
      },
    },
    shadows: {
      small: { value: '0 2px 4px rgba(0, 0, 0, 0.1)' },
      medium: { value: '0 4px 6px rgba(0, 0, 0, 0.1)' },
      large: { value: '0 8px 12px rgba(0, 0, 0, 0.1)' },
    },
  },
};
```

### hooks/useBadges.ts

```
// src/hooks/useBadges.ts
import { useState, useEffect, useCallback } from 'react';
import { generateClient } from 'aws-amplify/api';
import { Badge, BadgeProgress, BadgeRequirementType, transformToBadge, transformToBadgeProgress } from '../types/badges';
import { ApiError } from '../types/common';
import type { Schema } from '../../amplify/data/resource';

export const useBadges = () => {
  const client = generateClient<Schema>();
  const [userBadges, setUserBadges] = useState<Badge[]>([]);
  const [badgeProgress, setBadgeProgress] = useState<BadgeProgress[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<ApiError | null>(null);

  // バッジ進捗確認関数
  const checkBadgeProgress = useCallback(async (type: BadgeRequirementType, value: string) => {
    try {
      // 特定の条件に一致するバッジを検索
      const badge = await client.models.Badge.list({
        filter: {
          requirementType: { eq: type },
          requirement: { eq: value }
        }
      });

      if (badge.data.length > 0) {
        // 既存の進捗を確認（ない場合は新規作成）
        const badgeId = badge.data[0].id;
        const existingProgress = badgeProgress.find(p => p.badgeId === badgeId);
        
        if (existingProgress) {
          // 既に完了済みなら何もしない
          if (existingProgress.isCompleted) {
            return;
          }
          
          // 進捗を更新
          const progressUpdate = await client.models.BadgeProgress.update({
            id: existingProgress.id,
            progress: 100,
            isCompleted: true,
            completedAt: new Date().toISOString(),
            lastUpdatedAt: new Date().toISOString()
          });

          if (progressUpdate?.data) {
            const updatedProgress = transformToBadgeProgress(progressUpdate.data);
            setBadgeProgress(prev => 
              prev.map(p => p.id === updatedProgress.id ? updatedProgress : p)
            );
          }
        } else {
          // 新規進捗を作成
          const userId = (await client.models.UserProfile.list({ limit: 1 })).data[0]?.userId || 'anonymous';
          
          const newProgress = await client.models.BadgeProgress.create({
            userId,
            badgeId,
            progress: 100,
            isCompleted: true,
            completedAt: new Date().toISOString(),
            lastUpdatedAt: new Date().toISOString()
          });

          if (newProgress?.data) {
            const createdProgress = transformToBadgeProgress(newProgress.data);
            setBadgeProgress(prev => [...prev, createdProgress]);
          }
        }
      }
    } catch (e) {
      const apiError = e as ApiError;
      setError({
        name: apiError.name || 'Error',
        message: apiError.message || 'Failed to check badge progress',
        code: apiError.code,
        stack: apiError.stack
      });
      console.error('Error checking badge progress:', e);
    }
  }, [client, badgeProgress]);

  // バッジデータ読み込み
  useEffect(() => {
    const loadBadges = async () => {
      try {
        setIsLoading(true);
        setError(null);
        
        // バッジと進捗を並行して取得
        const [badgesResult, progressResult] = await Promise.all([
          client.models.Badge.list({}),
          client.models.BadgeProgress.list({})
        ]);
        
        if (badgesResult?.data) {
          const transformedBadges = badgesResult.data.map(transformToBadge);
          setUserBadges(transformedBadges);
        }

        if (progressResult?.data) {
          const transformedProgress = progressResult.data.map(transformToBadgeProgress);
          setBadgeProgress(transformedProgress);
        }
      } catch (e) {
        const apiError = e as ApiError;
        setError({
          name: apiError.name || 'Error',
          message: apiError.message || 'Failed to load badges',
          code: apiError.code,
          stack: apiError.stack
        });
        console.error('Error loading badges:', e);
      } finally {
        setIsLoading(false);
      }
    };

    loadBadges();
  }, [client]);

  return {
    userBadges,
    badgeProgress,
    isLoading,
    error,
    checkBadgeProgress
  };
};
```

### hooks/useInfiniteContents.tsx

```
// src/hooks/useInfiniteContents.tsx
import { useState, useCallback } from 'react';
import { generateClient } from 'aws-amplify/api';
import { type Schema } from '../../amplify/data/resource';
import { Content } from '../types/content';
import { ApiError, FilterOptions } from '../types/common';

interface InfiniteContentOptions {
  filter?: FilterOptions;
  limit?: number;
}

export const useInfiniteContents = () => {
  const client = generateClient<Schema>();

  const [items, setItems] = useState<Content[]>([]);
  const [nextToken, setNextToken] = useState<string | null>(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<ApiError | null>(null);

  // 項目リセット関数
  const resetItems = useCallback(() => {
    setItems([]);
    setNextToken(null);
    setError(null);
  }, []);

  // データ読み込み関数
  const loadMore = useCallback(async (options: InfiniteContentOptions = {}) => {
    try {
      setLoading(true);
      const resp = await client.models.Content.list({
        ...options,
        nextToken,
      });

      if (resp.errors && resp.errors.length > 0) {
        throw new Error(resp.errors[0].message);
      }
      
      const data = resp.data || [];
      setItems((prev) => [...prev, ...(data as unknown as Content[])]);
      setNextToken(resp.nextToken || null);
    } catch (e) {
      const apiError = e as ApiError;
      setError({
        name: apiError.name || 'Error',
        message: apiError.message || 'Failed to load more content',
        code: apiError.code,
        stack: apiError.stack
      });
    } finally {
      setLoading(false);
    }
  }, [client, nextToken]);

  return {
    items,
    loadMore,
    hasMore: nextToken != null,
    loading,
    error,
    resetItems,
  };
};
```

### hooks/useContent.tsx

```
// src/hooks/useContent.tsx
import { useState } from 'react';
import { ApiError, FilterOptions, PaginationOptions } from '../types/common';
import { Content, ContentResult } from '../types/content';
import { MockStorageService } from '../services/mockStorage';

// より具体的な型でリクエストオプションを定義
export interface ContentOptions extends PaginationOptions {
  filter?: FilterOptions;
}

// モックコンテンツデータ
const MOCK_CONTENTS: Content[] = [
  {
    id: 'content-1',
    title: 'メインストーリー第1章',
    description: 'メインストーリーの第1章です。',
    primaryTypes: ['story'],
    primaryCategory: 'MAIN_STORY',
    worldType: 'COMMON',
    attribution: 'OFFICIAL',
    visibility: 'PUBLIC',
    status: 'PUBLISHED',
    createdAt: '2023-01-01T00:00:00Z',
    updatedAt: '2023-01-01T00:00:00Z',
    version: '1.0.0',
    mainKey: 'stories/main/chapter1.txt',
    ownerId: 'admin',
  },
  {
    id: 'content-2',
    title: 'サイドストーリー：始まりの日',
    description: '世界の成り立ちに関するサイドストーリー',
    primaryTypes: ['story'],
    primaryCategory: 'SIDE_STORY',
    worldType: 'QUXE',
    attribution: 'OFFICIAL',
    visibility: 'PUBLIC',
    status: 'PUBLISHED',
    createdAt: '2023-01-02T00:00:00Z',
    updatedAt: '2023-01-02T00:00:00Z',
    version: '1.0.0',
    mainKey: 'stories/side/beginnings.txt',
    ownerId: 'admin',
  },
  {
    id: 'content-3',
    title: 'アイデア体の基礎',
    description: 'アイデア体の基本的な性質に関する研究資料',
    primaryTypes: ['document'],
    primaryCategory: 'THEORY',
    worldType: 'ALSAREJIA',
    attribution: 'OFFICIAL',
    visibility: 'AUTHENTICATED',
    status: 'PUBLISHED',
    createdAt: '2023-01-03T00:00:00Z',
    updatedAt: '2023-01-03T00:00:00Z',
    version: '1.0.0',
    mainKey: 'laboratory/ideas/basic-concept.md',
    ownerId: 'admin',
  }
];

// フック実装
export const useContent = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<ApiError | null>(null);

  // コンテンツの取得
  const getContent = async (id: string): Promise<Content | null> => {
    setLoading(true);
    try {
      // 遅延をシミュレート
      await new Promise(resolve => setTimeout(resolve, 300));
      
      const content = MOCK_CONTENTS.find(item => item.id === id);
      if (!content) {
        throw new Error('Content not found');
      }
      
      return content;
    } catch (e) {
      const apiError = e as ApiError;
      setError({
        name: apiError.name || 'Error',
        message: apiError.message || 'Failed to get content',
        code: apiError.code,
        stack: apiError.stack
      });
      throw apiError;
    } finally {
      setLoading(false);
    }
  };

  // コンテンツ一覧の取得
  const listContents = async (options?: ContentOptions): Promise<ContentResult> => {
    setLoading(true);
    try {
      // 遅延をシミュレート
      await new Promise(resolve => setTimeout(resolve, 300));
      
      let filteredContents = [...MOCK_CONTENTS];
      
      // フィルタリングをシミュレート
      if (options?.filter) {
        const filter = options.filter;
        
        filteredContents = filteredContents.filter(content => {
          let match = true;
          
          // カテゴリでフィルタリング
          if (filter.category && content.primaryCategory !== filter.category) {
            match = false;
          }
          
          // ワールドタイプでフィルタリング
          if (filter.worldType && content.worldType !== filter.worldType) {
            match = false;
          }
          
          return match;
        });
      }
      
      // ページネーションをシミュレート
      const limit = options?.limit || 10;
      const startIndex = 0; // 簡略化のため常に最初のページを返す
      const paginatedContents = filteredContents.slice(startIndex, startIndex + limit);
      
      return {
        items: paginatedContents,
        nextToken: paginatedContents.length === limit ? String(startIndex + limit) : undefined
      };
    } catch (e) {
      const apiError = e as ApiError;
      setError({
        name: apiError.name || 'Error',
        message: apiError.message || 'Failed to list contents',
        code: apiError.code,
        stack: apiError.stack
      });
      throw apiError;
    } finally {
      setLoading(false);
    }
  };

  // ストレージからファイルのコンテンツを取得
  const getFileContent = async (path: string): Promise<string> => {
    try {
      return await MockStorageService.getText(path);
    } catch (e) {
      const apiError = e as ApiError;
      setError({
        name: apiError.name || 'Error',
        message: apiError.message || 'Failed to get file content',
        code: apiError.code,
        stack: apiError.stack
      });
      throw apiError;
    }
  };

  // エラーリセット関数
  const resetError = () => {
    setError(null);
  };

  return {
    loading,
    error,
    getContent,
    listContents,
    getFileContent,
    resetError
  };
};
```

### assets/react.svg

```
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
```

### pages/materials/HodemeiMaterials.tsx

```
// src/pages/materials/HodemeiMaterials.tsx
import { useEffect, useState } from 'react';
import { MaterialsLayout } from '../../components/materials/MaterialsLayout';
import { Collection, View, ToggleButtonGroup, ToggleButton, Tabs, Button } from '@aws-amplify/ui-react';

import { AdvancedFilterPanel } from '../../components/common/AdvancedFilterPanel';
import { SkeletonList } from '../../components/common/SkeletonList';
import { ErrorAlert } from '../../components/common/ErrorAlert';
import { DocumentCard } from '../../components/materials/DocumentCard';
import { LibraryListViewItem } from '../../components/common/LibraryListViewItem';

import { useInfiniteContents } from '../../hooks/useInfiniteContents'; 
import { MaterialDocument } from '../../types/materials';

export const HodemeiMaterials = () => {
  // フィルタ条件
  const [filterCondition, setFilterCondition] = useState({
    keyword: '',
    world: 'all',
    tags: [] as string[],
  });

  // 表示モード
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  // attribution
  const [attribution, setAttribution] = useState<'official' | 'shared'>('official');
  // Tabs
  const [selectedCategory, setSelectedCategory] = useState('TECHNOLOGY');

  const {
    items,
    loadMore,
    hasMore,
    loading,
    error,
    resetItems, // 新しく追加(後述)
  } = useInfiniteContents();

  // フィルタ変更時に itemsをリセットして再取得するイメージ
  useEffect(() => {
    resetItems(); // itemsを空に
    loadMore({
      filter: {
        // 例: 
        //   and: [
        //     { worldType: { eq: "HODEMEI" } },
        //     { attribution: { eq: attribution === 'official' ? 'OFFICIAL' : 'SHARED' } },
        //     { or: [ { title: { matchPhrase: filterCondition.keyword } }, { description: {...} } ] }
        //   ]
      },
      limit: 6,
    });
  }, [filterCondition, attribution, resetItems, loadMore]);

  // GraphQLから取得した items を Document用にmapping
  const mappedItems: MaterialDocument[] = items.map((item) => ({
    id: item.id,
    title: item.title ?? 'No title',
    description: item.description ?? 'No desc',
    category: selectedCategory as any,
    reference: 'HOD-001',
    linkTo: `/materials/${attribution}/hodemei/${item.id}`,
    isAvailable: true,
    variant: 'document',
    imagePath: '/images/materials/tech-system.jpg',
  }));

  return (
    <MaterialsLayout
      title="Hodemei 設定資料"
      description="科学の極限を追求した世界、Hodemeiの資料を整理しています。"
    >
      <View padding="1rem">
        {/* アトリビューション */}
        <ToggleButtonGroup
          value={attribution}
          isExclusive
          onChange={(value) => setAttribution(value as 'official' | 'shared')}
          marginBottom="1rem"
        >
          <ToggleButton value="official">公式設定</ToggleButton>
          <ToggleButton value="shared">共有設定</ToggleButton>
        </ToggleButtonGroup>

        {/* 高度なフィルタ */}
        <AdvancedFilterPanel
          availableTags={['先端科学', 'ロボット', 'AI', '社会']}
          availableWorlds={['QUXE', 'HODEMEI', 'ALSAREJIA']}
          onChange={(newFilter) => setFilterCondition(newFilter)}
        />

        {/* ViewMode切り替え */}
        <ToggleButtonGroup
          value={viewMode}
          isExclusive
          onChange={(value) => setViewMode(value as 'grid' | 'list')}
          margin="1rem 0"
        >
          <ToggleButton value="grid">グリッド</ToggleButton>
          <ToggleButton value="list">リスト</ToggleButton>
        </ToggleButtonGroup>

        {/* タブ例 */}
        <Tabs
          spacing="equal"
          value={selectedCategory}
          onChange={(e) => {
            const target = e.target as HTMLButtonElement;
            setSelectedCategory(target.value);
          }}
        >
          <Tabs.List>
            <Tabs.Item value="TECHNOLOGY">科学技術</Tabs.Item>
            <Tabs.Item value="SOCIETY">社会構造</Tabs.Item>
            <Tabs.Item value="ORGANIZATION">組織</Tabs.Item>
            <Tabs.Item value="CHARACTER">キャラクター</Tabs.Item>
            <Tabs.Item value="LOCATION">地理</Tabs.Item>
            <Tabs.Item value="HISTORY">歴史</Tabs.Item>
          </Tabs.List>
        </Tabs>

        {/* エラー表示 */}
        {error && <ErrorAlert errorMessage={error.message || 'エラーが発生しました'} onDismiss={() => {}} />}

        {/* ローディング&表示 */}
        {loading && items.length === 0 ? (
          <SkeletonList count={4} />
        ) : (
          <>
            {viewMode === 'grid' && (
              <Collection
                type="grid"
                items={mappedItems}
                gap="medium"
                templateColumns={{
                  base: '1fr',
                  medium: '1fr 1fr',
                  large: '1fr 1fr 1fr',
                }}
              >
                {(item) => <DocumentCard key={item.id} {...item} />}
              </Collection>
            )}

            {viewMode === 'list' && (
              <Collection
                type="list"
                items={mappedItems}
                gap="small"
              >
                {(item) => (
                  <LibraryListViewItem
                    key={item.id}
                    id={item.id}
                    title={item.title}
                    description={item.description}
                    isAvailable={item.isAvailable}
                    reference={item.reference}
                    linkTo={item.linkTo}
                    category={item.category}
                  />
                )}
              </Collection>
            )}
          </>
        )}

        {/* Load More */}
        {hasMore && !loading && (
          <Button onClick={() => loadMore()} marginTop="1rem">
            さらに読み込む
          </Button>
        )}

        {loading && items.length > 0 && (
          <View marginTop="1rem">
            <SkeletonList count={2} />
          </View>
        )}
      </View>
    </MaterialsLayout>
  );
};

```

### pages/materials/MaterialDetailPage.tsx

```
// src/pages/materials/MaterialDetailPage.tsx
import { useParams, useNavigate } from 'react-router-dom';
import { View, Heading, Text, Image, Card, Flex, Button } from '@aws-amplify/ui-react';
import { useEffect, useState } from 'react';

interface MaterialDoc {
  id: string;
  title: string;
  description: string;
  attribution: 'official' | 'shared';
  world: 'hodemei' | 'quxe' | 'alsarejia' | 'common';
  imagePath?: string;
  content?: string; // テキスト本文など
}

// 仮のダミーデータ
const MOCK_MATERIALS: MaterialDoc[] = [
  {
    id: 'doc001',
    title: 'Hodemeiの先端科学',
    description: 'Hodemei世界における科学技術のあれこれ',
    attribution: 'official',
    world: 'hodemei',
    imagePath: '/images/materials/tech-system.jpg',
    content: '詳細な科学設定や基礎理論について...'
  }
];

export const MaterialDetailPage = () => {
  const { attribution, world, materialId } = useParams();
  const navigate = useNavigate();

  const [doc, setDoc] = useState<MaterialDoc | null>(null);

  useEffect(() => {
    // 実際にはGraphQL / S3などから fetch
    const found = MOCK_MATERIALS.find(
      (item) =>
        item.id === materialId &&
        item.attribution === attribution &&
        item.world === world
    );
    setDoc(found || null);
  }, [attribution, world, materialId]);

  if (!doc) {
    return (
      <View padding="2rem" textAlign="center">
        <Heading level={3}>資料が見つかりません</Heading>
        <Button onClick={() => navigate(-1)} marginTop="1rem">
          戻る
        </Button>
      </View>
    );
  }

  return (
    <View padding="2rem">
      <Button 
        onClick={() => navigate(-1)} 
        marginBottom="1rem"
      >
        ← 一覧へ戻る
      </Button>

      <Card variation="elevated">
        <Flex direction="column" gap="small">
          <Heading level={2}>{doc.title}</Heading>
          <Text>
            {doc.attribution === 'official' ? '公式資料' : '共有資料'} / {doc.world}
          </Text>
          {doc.imagePath && (
            <Image
              src={doc.imagePath}
              alt={doc.title}
              width="100%"
              maxHeight="300px"
              objectFit="cover"
            />
          )}
          <Text marginTop="1rem">{doc.description}</Text>

          {doc.content && (
            <Text marginTop="1rem" whiteSpace="pre-wrap">
              {doc.content}
            </Text>
          )}
        </Flex>
      </Card>
    </View>
  );
};

```

### pages/materials/AlsarejiaMaterials.tsx

```
// src/pages/materials/AlsarejiaMaterials.tsx
import { useEffect, useState } from 'react';
import { MaterialsLayout } from '../../components/materials/MaterialsLayout';
import {
  View,
  ToggleButtonGroup,
  ToggleButton,
  Tabs,
  Collection,
  Button,
} from '@aws-amplify/ui-react';

import { AdvancedFilterPanel } from '../../components/common/AdvancedFilterPanel';
import { SkeletonList } from '../../components/common/SkeletonList';
import { ErrorAlert } from '../../components/common/ErrorAlert';
import { LibraryListViewItem } from '../../components/common/LibraryListViewItem';
import { DocumentCard } from '../../components/materials/DocumentCard';

import { useInfiniteContents } from '../../hooks/useInfiniteContents';
import { MaterialDocument } from '../../types/materials';

export const AlsarejiaMaterials = () => {
  const [filterCondition, setFilterCondition] = useState({
    keyword: '',
    world: 'all',
    tags: [] as string[],
  });

  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [attribution, setAttribution] = useState<'official' | 'shared'>('official');
  const [selectedCategory, setSelectedCategory] = useState('FACILITY');

  const {
    items,
    loadMore,
    hasMore,
    loading,
    error,
    resetItems,
  } = useInfiniteContents();

  useEffect(() => {
    resetItems();
    loadMore({
      filter: {
        // 例: ALSAREJIAフィルタ
      },
      limit: 6,
    });
  }, [filterCondition, attribution, selectedCategory, resetItems, loadMore]);

  const mappedItems: MaterialDocument[] = items.map((item) => ({
    id: item.id,
    title: item.title ?? 'Untitled Alsarejia',
    description: item.description ?? 'No description',
    category: selectedCategory as any,
    reference: 'ALS-001',
    linkTo: `/materials/${attribution}/alsarejia/${item.id}`,
    isAvailable: true,
    variant: 'document',
    imagePath: '/images/materials/facility-overview.jpg',
  }));

  return (
    <MaterialsLayout
      title="Alsarejia 設定資料"
      description="全ての物語が交差する不思議な研究施設、Alsarejiaの資料を整理しています。"
    >
      <View padding="1rem">
        <ToggleButtonGroup
          value={attribution}
          isExclusive
          onChange={(value) => setAttribution(value as 'official' | 'shared')}
          marginBottom="1rem"
        >
          <ToggleButton value="official">公式設定</ToggleButton>
          <ToggleButton value="shared">共有設定</ToggleButton>
        </ToggleButtonGroup>

        <AdvancedFilterPanel
          availableTags={['施設', '実験', '特殊技術', '歴史']}
          availableWorlds={['ALSAREJIA', 'QUXE', 'HODEMEI']}
          onChange={(newFilter) => setFilterCondition(newFilter)}
        />

        <ToggleButtonGroup
          value={viewMode}
          isExclusive
          onChange={(value) => setViewMode(value as 'grid' | 'list')}
          margin="1rem 0"
        >
          <ToggleButton value="grid">グリッド</ToggleButton>
          <ToggleButton value="list">リスト</ToggleButton>
        </ToggleButtonGroup>

        <Tabs
          spacing="equal"
          value={selectedCategory}
          onChange={(e) => {
            const target = e.target as HTMLButtonElement;
            setSelectedCategory(target.value);
          }}
        >
          <Tabs.List>
            <Tabs.Item value="FACILITY">研究施設</Tabs.Item>
            <Tabs.Item value="IDEA">アイデア体</Tabs.Item>
            <Tabs.Item value="TECH">特殊技術</Tabs.Item>
            <Tabs.Item value="CHARACTER">キャラクター</Tabs.Item>
            <Tabs.Item value="HISTORY">歴史</Tabs.Item>
          </Tabs.List>
        </Tabs>

        {error && <ErrorAlert errorMessage={error.message || 'エラーが発生しました'} onDismiss={() => {}} />}

        {loading && items.length === 0 ? (
          <SkeletonList count={4} />
        ) : (
          <>
            {viewMode === 'grid' && (
              <Collection
                type="grid"
                items={mappedItems}
                gap="medium"
                templateColumns={{
                  base: '1fr',
                  medium: '1fr 1fr',
                  large: '1fr 1fr 1fr',
                }}
              >
                {(item) => <DocumentCard key={item.id} {...item} />}
              </Collection>
            )}
            {viewMode === 'list' && (
              <Collection type="list" items={mappedItems} gap="small">
                {(item) => (
                  <LibraryListViewItem
                    key={item.id}
                    id={item.id}
                    title={item.title}
                    description={item.description}
                    isAvailable={item.isAvailable}
                    reference={item.reference}
                    linkTo={item.linkTo}
                    category={item.category}
                  />
                )}
              </Collection>
            )}
          </>
        )}

        {hasMore && !loading && (
          <Button onClick={() => loadMore()} marginTop="1rem">
            さらに読み込む
          </Button>
        )}
        {loading && items.length > 0 && <SkeletonList count={2} />}
      </View>
    </MaterialsLayout>
  );
};

```

### pages/materials/QuxeMaterials.tsx

```
// src/pages/materials/QuxeMaterials.tsx
import { useEffect, useState } from 'react';
import { MaterialsLayout } from '../../components/materials/MaterialsLayout';
import {
  View,
  ToggleButtonGroup,
  ToggleButton,
  Tabs,
  Collection,
  Button,
} from '@aws-amplify/ui-react';

import { AdvancedFilterPanel } from '../../components/common/AdvancedFilterPanel';
import { SkeletonList } from '../../components/common/SkeletonList';
import { ErrorAlert } from '../../components/common/ErrorAlert';
import { LibraryListViewItem } from '../../components/common/LibraryListViewItem';
import { DocumentCard } from '../../components/materials/DocumentCard';

import { useInfiniteContents } from '../../hooks/useInfiniteContents';
import { MaterialDocument } from '../../types/materials';

export const QuxeMaterials = () => {
  const [filterCondition, setFilterCondition] = useState({
    keyword: '',
    world: 'all',
    tags: [] as string[],
  });

  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');
  const [attribution, setAttribution] = useState<'official' | 'shared'>('official');

  // 選択中のタブ（Quxe内のカテゴリ）  
  const [selectedCategory, setSelectedCategory] = useState('MAGIC');

  const {
    items,
    loadMore,
    hasMore,
    loading,
    error,
    resetItems,
  } = useInfiniteContents();

  // フィルタ/タブ変更ごとにリセット&再ロード
  useEffect(() => {
    resetItems();
    loadMore({
      filter: {
        // 例: QUXEコンテンツのみ読みたい等 => worldType eq "QUXE"
      },
      limit: 6,
    });
  }, [filterCondition, attribution, selectedCategory, resetItems, loadMore]);

  // ダミー変換
  const mappedItems: MaterialDocument[] = items.map((item) => ({
    id: item.id,
    title: item.title ?? 'Untitled Quxe',
    description: item.description ?? 'No description',
    category: selectedCategory as any,
    reference: 'QUX-XXX',
    linkTo: `/materials/${attribution}/quxe/${item.id}`,
    isAvailable: true,
    variant: 'document',
    imagePath: '/images/materials/magic-basics.jpg',
  }));

  return (
    <MaterialsLayout
      title="Quxe 設定資料"
      description="魔法と精霊が織りなす神秘的な世界、Quxeの資料を整理しています。"
    >
      <View padding="1rem">
        <ToggleButtonGroup
          value={attribution}
          isExclusive
          onChange={(value) => setAttribution(value as 'official' | 'shared')}
          marginBottom="1rem"
        >
          <ToggleButton value="official">公式設定</ToggleButton>
          <ToggleButton value="shared">共有設定</ToggleButton>
        </ToggleButtonGroup>

        <AdvancedFilterPanel
          availableTags={['魔法基礎', '精霊', '呪文', '歴史']}
          availableWorlds={['QUXE', 'HODEMEI', 'ALSAREJIA']}
          onChange={(newFilter) => setFilterCondition(newFilter)}
        />

        <ToggleButtonGroup
          value={viewMode}
          isExclusive
          onChange={(value) => setViewMode(value as 'grid' | 'list')}
          margin="1rem 0"
        >
          <ToggleButton value="grid">グリッド</ToggleButton>
          <ToggleButton value="list">リスト</ToggleButton>
        </ToggleButtonGroup>

        <Tabs
          spacing="equal"
          value={selectedCategory}
          onChange={(e) => {
            const target = e.target as HTMLButtonElement;
            setSelectedCategory(target.value);
          }}
        >
          <Tabs.List>
            <Tabs.Item value="MAGIC">魔法体系</Tabs.Item>
            <Tabs.Item value="ARTIFACT">魔法道具</Tabs.Item>
            <Tabs.Item value="ORGANIZATION">組織</Tabs.Item>
            <Tabs.Item value="CHARACTER">キャラクター</Tabs.Item>
            <Tabs.Item value="LOCATION">地理</Tabs.Item>
            <Tabs.Item value="HISTORY">歴史</Tabs.Item>
          </Tabs.List>
        </Tabs>

        {error && <ErrorAlert errorMessage={error.message || 'エラーが発生しました'} onDismiss={() => {}} />}

        {loading && items.length === 0 ? (
          <SkeletonList count={4} />
        ) : (
          <>
            {viewMode === 'grid' && (
              <Collection
                type="grid"
                items={mappedItems}
                gap="medium"
                templateColumns={{
                  base: '1fr',
                  medium: '1fr 1fr',
                  large: '1fr 1fr 1fr',
                }}
              >
                {(item) => <DocumentCard key={item.id} {...item} />}
              </Collection>
            )}
            {viewMode === 'list' && (
              <Collection type="list" items={mappedItems} gap="small">
                {(item) => (
                  <LibraryListViewItem
                    key={item.id}
                    id={item.id}
                    title={item.title}
                    description={item.description}
                    isAvailable={item.isAvailable}
                    reference={item.reference}
                    linkTo={item.linkTo}
                    category={item.category}
                  />
                )}
              </Collection>
            )}
          </>
        )}

        {hasMore && !loading && (
          <Button onClick={() => loadMore()} marginTop="1rem">
            さらに読み込む
          </Button>
        )}
        {loading && items.length > 0 && <SkeletonList count={2} />}
      </View>
    </MaterialsLayout>
  );
};

```

### pages/materials/MaterialsAbout.tsx

```
// src/pages/materials/MaterialsAbout.tsx
import { useEffect, useState } from 'react';
import { MaterialsLayout } from '../../components/materials/MaterialsLayout';
import {
  View,
  ToggleButtonGroup,
  ToggleButton,
  Collection,
  Button,
} from '@aws-amplify/ui-react';

import { AdvancedFilterPanel } from '../../components/common/AdvancedFilterPanel';
import { SkeletonList } from '../../components/common/SkeletonList';
import { ErrorAlert } from '../../components/common/ErrorAlert';
import { LibraryListViewItem } from '../../components/common/LibraryListViewItem';
import { DocumentCard } from '../../components/materials/DocumentCard';

import { useInfiniteContents } from '../../hooks/useInfiniteContents';
import { MaterialDocument, MaterialCategory } from '../../types/materials';

export const MaterialsAbout = () => {
  const [filterCondition, setFilterCondition] = useState({
    keyword: '',
    world: 'all',
    tags: [] as string[],
  });
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');

  const {
    items,
    loadMore,
    hasMore,
    loading,
    error,
    resetItems,
  } = useInfiniteContents();

  useEffect(() => {
    resetItems();
    loadMore({
      filter: {
        // 例: "SETTING_MATERIAL" など
      },
      limit: 6,
    });
  }, [filterCondition, resetItems, loadMore]);

  const mappedItems: MaterialDocument[] = items.map((item) => ({
    id: item.id,
    title: item.title ?? 'Materials Title',
    description: item.description ?? 'No description',
    category: MaterialCategory.WORLD,
    reference: 'REF-xxx',
    linkTo: `/materials/about/${item.id}`,
    isAvailable: true,
    variant: 'document',
    imagePath: ''
  }));

  return (
    <MaterialsLayout
      title="設定資料室"
      description="Project Nifercheの設定資料をご覧いただけます。"
    >
      <View padding="1rem">
        <AdvancedFilterPanel
          availableTags={['共通', 'Quxe', 'Hodemei', 'Alsarejia']}
          availableWorlds={['COMMON', 'QUXE', 'HODEMEI', 'ALSAREJIA']}
          onChange={(newFilter) => setFilterCondition(newFilter)}
        />

        <ToggleButtonGroup
          value={viewMode}
          isExclusive
          onChange={(value) => setViewMode(value as 'grid' | 'list')}
          margin="1rem 0"
        >
          <ToggleButton value="grid">グリッド</ToggleButton>
          <ToggleButton value="list">リスト</ToggleButton>
        </ToggleButtonGroup>

        {error && <ErrorAlert errorMessage={error.message || 'エラーが発生しました'} onDismiss={() => {}} />}

        {loading && items.length === 0 ? (
          <SkeletonList count={4} />
        ) : (
          <>
            {viewMode === 'grid' && (
              <Collection
                type="grid"
                items={mappedItems}
                gap="medium"
                templateColumns={{
                  base: '1fr',
                  medium: '1fr 1fr',
                  large: '1fr 1fr 1fr',
                }}
              >
                {(item) => <DocumentCard key={item.id} {...item} />}
              </Collection>
            )}
            {viewMode === 'list' && (
              <Collection type="list" items={mappedItems} gap="small">
                {(item) => (
                  <LibraryListViewItem
                    key={item.id}
                    id={item.id}
                    title={item.title}
                    description={item.description}
                    isAvailable={item.isAvailable}
                    reference={item.reference}
                    linkTo={item.linkTo}
                    category={item.category}
                  />
                )}
              </Collection>
            )}
          </>
        )}

        {hasMore && !loading && (
          <Button onClick={() => loadMore()} marginTop="1rem">
            さらに読み込む
          </Button>
        )}
        {loading && items.length > 0 && <SkeletonList count={2} />}
      </View>
    </MaterialsLayout>
  );
};

```

### pages/materials/CommonSettings.tsx

```
// src/pages/materials/CommonSettings.tsx
import { useEffect, useState } from 'react';
import { MaterialsLayout } from '../../components/materials/MaterialsLayout';
import {
  View,
  ToggleButtonGroup,
  ToggleButton,
  Collection,
  Button,
} from '@aws-amplify/ui-react';

import { AdvancedFilterPanel } from '../../components/common/AdvancedFilterPanel';
import { SkeletonList } from '../../components/common/SkeletonList';
import { ErrorAlert } from '../../components/common/ErrorAlert';
import { LibraryListViewItem } from '../../components/common/LibraryListViewItem';
import { DocumentCard } from '../../components/materials/DocumentCard';

import { useInfiniteContents } from '../../hooks/useInfiniteContents';
import { MaterialDocument, MaterialCategory } from '../../types/materials';

export const CommonSettings = () => {
  const [filterCondition, setFilterCondition] = useState({
    keyword: '',
    world: 'all',
    tags: [] as string[],
  });

  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');

  const {
    items,
    loadMore,
    hasMore,
    loading,
    error,
    resetItems,
  } = useInfiniteContents();

  useEffect(() => {
    resetItems();
    loadMore({
      filter: {
        // 例: category eq "THEORY" ...
      },
      limit: 6,
    });
  }, [filterCondition, resetItems, loadMore]);

  const mappedItems: MaterialDocument[] = items.map((item) => ({
    id: item.id,
    title: item.title ?? 'Common Setting Title',
    description: item.description ?? 'No description',
    category: MaterialCategory.THEORY,
    reference: 'COM-xxx',
    linkTo: `/materials/common/${item.id}`,
    isAvailable: true,
    variant: 'manuscript',
    imagePath: ''
  }));

  return (
    <MaterialsLayout
      title="共通設定資料"
      description="Project Nifercheの基盤となる理論体系や言語など。"
    >
      <View padding="1rem">
        <AdvancedFilterPanel
          availableTags={['理論', '言語', '基礎']}
          availableWorlds={['COMMON', 'QUXE', 'HODEMEI', 'ALSAREJIA']}
          onChange={(newFilter) => setFilterCondition(newFilter)}
        />

        <ToggleButtonGroup
          value={viewMode}
          isExclusive
          onChange={(value) => setViewMode(value as 'grid' | 'list')}
          margin="1rem 0"
        >
          <ToggleButton value="grid">グリッド</ToggleButton>
          <ToggleButton value="list">リスト</ToggleButton>
        </ToggleButtonGroup>

        {error && <ErrorAlert errorMessage={error.message || 'エラーが発生しました'} onDismiss={() => {}} />}

        {loading && items.length === 0 ? (
          <SkeletonList count={4} />
        ) : (
          <>
            {viewMode === 'grid' && (
              <Collection
                type="grid"
                items={mappedItems}
                gap="medium"
                templateColumns={{
                  base: '1fr',
                  medium: '1fr 1fr',
                  large: '1fr 1fr 1fr',
                }}
              >
                {(item) => <DocumentCard key={item.id} {...item} />}
              </Collection>
            )}
            {viewMode === 'list' && (
              <Collection type="list" items={mappedItems} gap="small">
                {(item) => (
                  <LibraryListViewItem
                    key={item.id}
                    id={item.id}
                    title={item.title}
                    description={item.description}
                    isAvailable={item.isAvailable}
                    reference={item.reference}
                    linkTo={item.linkTo}
                    category={item.category}
                  />
                )}
              </Collection>
            )}
          </>
        )}

        {hasMore && !loading && (
          <Button onClick={() => loadMore()} marginTop="1rem">
            さらに読み込む
          </Button>
        )}
        {loading && items.length > 0 && <SkeletonList count={2} />}
      </View>
    </MaterialsLayout>
  );
};

```

### pages/laboratory/IdeaLibrary.tsx

```
// src/pages/laboratory/IdeaLibrary.tsx
import React, { useState } from 'react';
import { 
 View, 
 Card, 
 Text, 
 Image, 
 Heading, 
 Flex, 
 Badge,
 useTheme,
 Button
} from '@aws-amplify/ui-react';
import { DetailModal } from '../../components/common/DetailModal';

// 研究資料の型定義
interface IdeaDocument {
 id: string;
 title: string; 
 description: string;
 category: 'basic' | 'advanced' | 'research';
 reference: string;
 isAvailable: boolean;
 variant: 'document' | 'image';
 imagePath?: string;
 tags: string[];
 details?: {
   title: string;
   content: string;
 }[];
 metadata?: Record<string, string>;
}

// モックデータ
const ideaDocs: IdeaDocument[] = [
 {
   id: 'idea-basics',
   title: 'アイデア体の基礎',
   description: 'アイデア体の基本的な性質と観測方法について解説します。研究を始める前に必ず確認してください。',
   category: 'basic',
   reference: 'IDE-001',
   isAvailable: true,
   variant: 'document',
   tags: ['入門', '基礎理論'],
   details: [
     {
       title: '概要',
       content: 'アイデア体とは、観測を通じて意味が収束し、共有可能な実在性を獲得した意味的実体です。'
     },
     {
       title: '基本特性',
       content: '精神的観測による意味の収束、複数の観測者間での共有可能性、独自の存在感と自律性などの特徴を持ちます。'
     }
   ],
   metadata: {
     '分類': '基礎理論',
     '公開日': '2024-01-15',
     '更新日': '2024-03-20',
     'バージョン': '1.2'
   }
 },
 // ... 他のモックデータ
];

export const IdeaLibrary: React.FC = () => {
 const [activeCategory, setActiveCategory] = useState<string>('basic');
 const [selectedDocument, setSelectedDocument] = useState<IdeaDocument | null>(null);
 const { tokens } = useTheme();

 return (
   <View 
     padding={{ base: '1rem', medium: '2rem' }}
     backgroundColor={tokens.colors.background.secondary}
   >
     <View 
       backgroundColor={tokens.colors.background.primary}
       padding={{ base: '1.5rem', medium: '2rem' }}
       borderRadius="medium"
     >
       <Heading level={1} marginBottom="1rem">
         アイデアライブラリ
       </Heading>
       
       <Text marginBottom="2rem">
         研究所で蓄積された、アイデア体に関する研究成果と理論をご覧いただけます。
       </Text>

       <Flex 
         gap="medium" 
         marginBottom="2rem"
         backgroundColor={tokens.colors.background.tertiary}
         padding="0.5rem"
         borderRadius="small"
       >
         {[
           { id: 'basic', label: '基礎理論' },
           { id: 'advanced', label: '発展研究' },
           { id: 'research', label: '研究手法' }
         ].map(tab => (
          <Button
          key={tab.id}
          onClick={() => setActiveCategory(tab.id)}
          variation={activeCategory === tab.id ? 'link' : 'menu'}
          backgroundColor={activeCategory === tab.id ? 
            tokens.colors.background.primary : 'transparent'}
          color={activeCategory === tab.id ? 
            tokens.colors.font.primary : tokens.colors.font.secondary}
        >
          {tab.label}
        </Button>
         ))}
       </Flex>

       <Flex gap="medium" wrap="wrap">
         {ideaDocs
           .filter(doc => doc.category === activeCategory)
           .map(doc => (
             <Card
               key={doc.id}
               padding={tokens.space.medium}
               backgroundColor={tokens.colors.background.primary}
               onClick={() => doc.isAvailable && setSelectedDocument(doc)}
               style={{
                 cursor: doc.isAvailable ? 'pointer' : 'default',
                 opacity: doc.isAvailable ? 1 : 0.7,
                 flex: '1 1 400px',
                 minHeight: '300px'
               }}
             >
               {doc.variant === 'image' && doc.imagePath && (
                 <Image
                   src={doc.imagePath}
                   alt={doc.title}
                   width="100%"
                   height="200px"
                   objectFit="cover"
                 />
               )}
               
               <Heading level={3} marginTop="1rem">{doc.title}</Heading>
               <Text marginTop="0.5rem">{doc.description}</Text>
               
               <Flex gap="small" marginTop="1rem" wrap="wrap">
                 {doc.tags.map(tag => (
                   <Badge key={tag} variation="info">{tag}</Badge>
                 ))}
               </Flex>

               <Flex justifyContent="space-between" marginTop="1rem">
                 <Badge variation={doc.isAvailable ? 'success' : 'warning'}>
                   {doc.isAvailable ? '閲覧可能' : '準備中'}
                 </Badge>
                 <Text variation="tertiary">{doc.reference}</Text>
               </Flex>
             </Card>
           ))}
       </Flex>
     </View>

     <DetailModal
       isOpen={!!selectedDocument}
       onClose={() => setSelectedDocument(null)}
       data={selectedDocument ? {
         id: selectedDocument.id,
         title: selectedDocument.title,
         description: selectedDocument.description,
         category: selectedDocument.category,
         imagePath: selectedDocument.imagePath,
         details: selectedDocument.details,
         metadata: selectedDocument.metadata,
         tags: selectedDocument.tags
       } : {
         id: '',
         title: '',
         description: '',
         category: '',
         tags: []
       }}
       entityType="research"
     />
   </View>
 );
};
```

### pages/laboratory/LaboratoryPage.tsx

```
// src/pages/laboratory/LaboratoryPage.tsx
import { 
  View, 
  Grid, 
  Text, 
  Card,
  Collection,
  Flex
} from '@aws-amplify/ui-react';
import { ContentCard } from '../../components/common/ContentCard';
import { ContentSection } from '../../components/common/ContentSection';

const mainSections = [
  {
    id: 'mainstory',
    title: 'Main Story',
    description: '記憶を失った研究者サレジアと、ニファーシェが織りなす物語',
    // 修正: linkToを "/library/mainstory" へ変更
    linkTo: '/library/mainstory',
    imageUrl: '/images/main-story.jpg',
    isAvailable: true
  },
  {
    id: 'sidestory',
    title: 'Side Stories',
    description: '様々な視点から描かれる物語',
    // 同じく修正(サイドストーリーは /library/sidestory)
    linkTo: '/library/sidestory',
    imageUrl: '/images/side-story.jpg',
    isAvailable: true
  }
];

const facilitySections = [
  {
    id: 'about',
    title: '研究施設について',
    description: 'Laboratory Alsarejiaの利用案内と規約',
    linkTo: '/laboratory/about',
    imageUrl: '/images/about.jpg',
    isAvailable: true
  },
  {
    id: 'ideas',
    title: 'アイデア体資料',
    description: 'アイデア体に関する研究資料',
    linkTo: '/laboratory/ideas',
    imageUrl: '/images/ideas.jpg',
    isAvailable: false
  }
];

const todaysResearch = {
  id: 'sample-research',
  title: 'サンプル研究報告書',
  content:
    '研究報告: #2024-001\n本日のアイデア体の観測により、興味深い現象が確認されました...',
  author: 'サレジア'
};

export const LaboratoryPage = () => {
  return (
    <View padding="2rem">
      {/* ヘッダーセクション */}
      <ContentSection
        variant="laboratory"
        title="Laboratory Alsarejia"
        description="世界の狭間に存在する不思議な研究施設。現実と想像の境界を探る研究が日々行われています。"
      >
        <Card
          variation="elevated"
          marginTop="1rem"
          padding="1rem"
          style={{ maxHeight: '120px', overflow: 'hidden' }}
        >
          <Flex direction="column" gap="small">
            <Text
              as="pre"
              whiteSpace="pre-wrap"
              fontSize="sm"
              style={{
                overflow: 'hidden',
                textOverflow: 'ellipsis',
                display: '-webkit-box',
                WebkitLineClamp: '3',
                WebkitBoxOrient: 'vertical'
              }}
            >
              {todaysResearch.content}
            </Text>
            <Text
              textAlign="right"
              fontStyle="italic"
              fontSize="sm"
              color="font.tertiary"
            >
              - {todaysResearch.author}
            </Text>
          </Flex>
        </Card>
      </ContentSection>

      {/* メインストーリーセクション */}
      <ContentSection
        variant="laboratory"
        title="Stories"
        description="現在公開中の物語"
      >
        <Collection
          type="grid"
          items={mainSections}
          gap="medium"
          templateColumns={{
            base: '1fr',
            medium: '1fr 1fr'
          }}
        >
          {(item) => (
            <ContentCard
              key={item.id}
              title={item.title}
              description={item.description}
              imagePath={item.imageUrl}
              linkTo={item.isAvailable ? item.linkTo : undefined}
              onClick={() => {
                if (!item.isAvailable) {
                  alert('このコンテンツは現在準備中です');
                }
              }}
            />
          )}
        </Collection>
      </ContentSection>

      {/* 施設情報セクション */}
      <ContentSection
        variant="laboratory"
        title="Facility"
        description="研究施設の利用案内"
      >
        <Grid
          templateColumns={{
            base: '1fr',
            medium: '1fr 1fr'
          }}
          gap="medium"
        >
          {facilitySections.map((section) => (
            <ContentCard
              key={section.id}
              title={section.title}
              description={section.description}
              imagePath={section.imageUrl}
              linkTo={section.isAvailable ? section.linkTo : undefined}
              onClick={() => {
                if (!section.isAvailable) {
                  alert('このコンテンツは現在準備中です');
                }
              }}
            />
          ))}
        </Grid>
      </ContentSection>

      {/* フッター的な要素 */}
      <Flex
        direction="column"
        alignItems="center"
        marginTop="4rem"
        padding="2rem"
        backgroundColor="background.secondary"
        borderRadius="medium"
      >
        <Text fontSize="sm" color="font.tertiary">
          「全ては観測者の意識の中に存在する」
        </Text>
      </Flex>
    </View>
  );
};

```

### pages/laboratory/FacilityGuide.tsx

```
// src/pages/laboratory/FacilityGuide.tsx
import React, { useState } from 'react';
import { 
  View, 
  Card, 
  Flex, 
  useTheme,
  Button
} from '@aws-amplify/ui-react';

// 施設ドキュメントの型定義
interface FacilityDocument {
  id: string;
  title: string;
  description: string;
  category: 'overview' | 'areas' | 'rules';
  reference: string;
  isAvailable: boolean;
  variant: 'image' | 'document';
  imagePath?: string;
  link?: string;
}

// 施設ドキュメントデータ
const facilityDocs: FacilityDocument[] = [
  {
    id: 'facility-map',
    title: '施設マップ',
    description: 'アルサレジア研究所の全体マップです。各エリアの配置と主要な設備の位置を確認できます。',
    category: 'overview',
    reference: 'FAC-001',
    isAvailable: true,
    variant: 'image',
    imagePath: '/images/laboratory/facility-map.jpg',
    link: '/laboratory/facility/map'
  },
  {
    id: 'facility-security',
    title: 'セキュリティガイド',
    description: '研究所内での安全管理と機密情報の取り扱いについての詳細なガイドラインです。',
    category: 'areas',
    reference: 'FAC-003',
    isAvailable: true,
    variant: 'document',
    link: '/laboratory/facility/security'
  },
  {
    id: 'facility-rules',
    title: '利用規約',
    description: '研究所の利用に関する基本的な規則と注意事項をまとめています。',
    category: 'rules',
    reference: 'FAC-002',
    isAvailable: true,
    variant: 'document',
    link: '/laboratory/facility/rules'
  }
];

export const FacilityGuide: React.FC = () => {
  const [activeCategory, setActiveCategory] = useState<FacilityDocument['category']>('overview');
  const { tokens } = useTheme();

  // タブボタンインターフェース
  interface TabItem {
    id: FacilityDocument['category'];
    label: string;
  }

  // タブボタンのレンダリング
  const renderTab = (tab: TabItem) => (
    <Button
      key={tab.id}
      onClick={() => setActiveCategory(tab.id)}
      backgroundColor={activeCategory === tab.id ? 
        tokens.colors.background.primary : 'transparent'}
      color={activeCategory === tab.id ? 
        tokens.colors.font.primary : tokens.colors.font.secondary}
      borderRadius="small"
      padding="0.75rem 1.5rem"
      variation="link"
    >
      {tab.label}
    </Button>
  );

  // カードのレンダリング
  const renderCard = (item: FacilityDocument) => (
    <Card
      key={item.id}
      padding="0"
      variation="elevated"
      backgroundColor={tokens.colors.background.primary}
      style={{
        flex: '1 1 400px',
        minHeight: '300px',
        cursor: item.isAvailable ? 'pointer' : 'default'
      }}
      onClick={() => item.isAvailable && item.link && window.location.assign(item.link)}
    >
      {/* ... カードの中身は同じ ... */}
    </Card>
  );

  const tabs: TabItem[] = [
    { id: 'overview', label: '概要' },
    { id: 'areas', label: 'エリア案内' },
    { id: 'rules', label: '利用規約' }
  ];

  return (
    <View 
      padding={{ base: '1rem', medium: '2rem' }}
      backgroundColor={tokens.colors.background.secondary}
    >
      {/* ... 他の部分は同じ ... */}
      
      <Flex 
        gap="medium" 
        marginBottom="2rem"
        backgroundColor={tokens.colors.background.tertiary}
        padding="0.5rem"
        borderRadius="small"
      >
        {tabs.map(tab => renderTab(tab))}
      </Flex>

      <Flex 
        gap="medium"
        wrap="wrap"
      >
        {facilityDocs
          .filter(doc => doc.category === activeCategory)
          .map(item => renderCard(item))}
      </Flex>
    </View>
  );
};
```

### pages/laboratory/ArchivePage.tsx

```
// src/pages/laboratory/ArchivePage.tsx
import { 
  View, 
  Heading, 
  Card, 
  Collection,
  Text, 
  Badge,
  Flex,
  SelectField,
  useTheme 
 } from '@aws-amplify/ui-react';
 import { ContentSection } from '../../components/common/ContentSection';
 import { DetailModal } from '../../components/common/DetailModal';
 import { useState } from 'react';
 
 interface ResearchRecord {
  id: string;
  title: string;
  summary: string;
  category: 'observation' | 'analysis' | 'theory' | 'interaction';
  date: string;
  author: string;
  status: 'verified' | 'under_review' | 'theoretical';
  relatedEntities: string[];
  tags: string[];
  details?: {
    title: string;
    content: string;
  }[];
 }
 
 const mockRecords: ResearchRecord[] = [
  {
    id: 'rec-001',
    title: 'アイデア体の共鳴現象に関する考察',
    summary: '複数のアイデア体間で観測された共鳴現象について、その特性と影響を分析する。',
    category: 'analysis',
    date: '2024-03-15',
    author: 'サレジア',
    status: 'verified',
    relatedEntities: ['idea-001', 'idea-003'],
    tags: ['共鳴', '相互作用', '理論研究'],
    details: [
      {
        title: '研究目的',
        content: 'アイデア体間の共鳴現象の特性を明らかにし、その影響範囲を定量的に評価することを目的とする。'
      },
      {
        title: '観測手法',
        content: '複数のアイデア体を同時に観測し、その相互作用を記録。現実性強度の変動パターンを分析。'
      },
      {
        title: '結論',
        content: '共鳴現象は双方のアイデア体の現実性を一時的に強化する効果があることが確認された。'
      }
    ]
  }
 ];
 
 export const ArchivePage = () => {
  const [categoryFilter, setCategoryFilter] = useState<string>('all');
  const [selectedRecord, setSelectedRecord] = useState<ResearchRecord | null>(null);
  const { tokens } = useTheme();
 
  const filteredRecords = mockRecords.filter(record => 
    categoryFilter === 'all' || record.category === categoryFilter
  );
 
  const getStatusVariation = (status: ResearchRecord['status']): "info" | "error" | "warning" | "success" => {
    switch (status) {
      case 'verified': return 'success';
      case 'under_review': return 'warning';
      case 'theoretical': return 'info';
      default: return 'info';
    }
   };
 
  const getStatusLabel = (status: ResearchRecord['status']) => {
    switch (status) {
      case 'verified': return '検証済';
      case 'under_review': return '査読中';
      case 'theoretical': return '理論研究';
      default: return status;
    }
  };
 
  return (
    <View padding={tokens.space.large}>
      <ContentSection
        title="研究アーカイブ"
        description="アイデア体に関する研究記録や分析結果のアーカイブです。"
      >
        <Flex gap="medium" marginBottom="large">
          <SelectField
            label="カテゴリフィルター"
            value={categoryFilter}
            onChange={e => setCategoryFilter(e.target.value)}
          >
            <option value="all">すべて表示</option>
            <option value="observation">観測記録</option>
            <option value="analysis">分析結果</option>
            <option value="theory">理論研究</option>
            <option value="interaction">相互作用</option>
          </SelectField>
        </Flex>
 
        <Collection
          type="grid"
          items={filteredRecords}
          gap={tokens.space.medium}
          templateColumns={{
            base: "1fr",
            medium: "1fr 1fr"
          }}
        >
          {(record) => (
            <Card
              key={record.id}
              padding={tokens.space.medium}
              variation="elevated"
              onClick={() => setSelectedRecord(record)}
              style={{ cursor: 'pointer' }}
            >
              <Flex direction="column" gap="small">
                <Flex justifyContent="space-between" alignItems="center">
                  <Heading level={3}>{record.title}</Heading>
                    <Badge variation={getStatusVariation(record.status)}>
                      {getStatusLabel(record.status)}
                    </Badge>
                </Flex>
 
                <Text>{record.summary}</Text>
 
                <Text fontSize="small">
                  著者: {record.author} | 日付: {record.date}
                </Text>
 
                <Flex gap="small" wrap="wrap">
                  {record.tags.map(tag => (
                    <Badge 
                      key={tag} 
                      variation="info"
                    >
                      {tag}
                    </Badge>
                  ))}
                </Flex>
              </Flex>
            </Card>
          )}
        </Collection>
      </ContentSection>
 
      <DetailModal
        isOpen={!!selectedRecord}
        onClose={() => setSelectedRecord(null)}
        data={selectedRecord ? {
          id: selectedRecord.id,
          title: selectedRecord.title,
          description: selectedRecord.summary,
          category: selectedRecord.category,
          details: selectedRecord.details,
          metadata: {
            '著者': selectedRecord.author,
            '日付': selectedRecord.date,
            'ステータス': getStatusLabel(selectedRecord.status)
          },
          tags: selectedRecord.tags
        } : {
          id: '',
          title: '',
          description: '',
          category: '',
          tags: []
        }}
        entityType="research"
      />
    </View>
  );
 };
```

### pages/laboratory/GuidePage.tsx

```
// src/pages/laboratory/GuidePage.tsx
import { 
  View, 
  Card, 
  Collection, 
  Text, 
  Heading,
  Image,
  Flex,
  useTheme,
  ToggleButtonGroup, 
  ToggleButton,
  Badge
 } from '@aws-amplify/ui-react';
 import { ContentSection } from '../../components/common/ContentSection';
 import { DetailModal } from '../../components/common/DetailModal';
 import { useState } from 'react';
 
 interface FacilityArea {
  id: string;
  name: string;
  description: string;
  category: 'research' | 'observation' | 'analysis' | 'common';
  accessLevel: 'all' | 'authorized' | 'restricted';
  features: string[];
  imagePath?: string;
  details?: {
    title: string;
    content: string;
  }[];
 }
 
 const facilityAreas: FacilityArea[] = [
  {
    id: 'central-lab',
    name: '中央研究室',
    description: 'アイデア体の基本的な観測と記録を行うための主要施設です。',
    category: 'research',
    accessLevel: 'all',
    features: [
      '基本観測装置',
      'データ記録システム',
      'リアルタイムモニタリング'
    ],
    imagePath: '/images/facility/central-lab.jpg',
    details: [
      {
        title: '設備概要',
        content: '最新の観測機器を備えた総合研究施設です。24時間体制で運営されています。'
      },
      {
        title: '利用方法',
        content: '基本的な利用は予約制となっています。緊急時は管理者に直接連絡してください。'
      }
    ]
  },
  {
    id: 'analysis-center',
    name: '解析センター',
    description: '収集されたデータの分析と理論研究を行う施設です。',
    category: 'analysis',
    accessLevel: 'authorized',
    features: [
      '大規模データ分析システム',
      '理論研究支援AI',
      '共同研究スペース'
    ],
    imagePath: '/images/facility/analysis-center.jpg',
    details: [
      {
        title: '主要設備',
        content: '大規模計算機システムと共同研究スペースを完備しています。'
      },
      {
        title: 'アクセス制限',
        content: '許可された研究者のみが利用できます。申請は管理部門で受け付けています。'
      }
    ]
  }
 ];
 
 export const GuidePage = () => {
  const [activeCategory, setActiveCategory] = useState<FacilityArea['category']>('research');
  const [selectedFacility, setSelectedFacility] = useState<FacilityArea | null>(null);
  const { tokens } = useTheme();
 
  const getAccessLevelConfig = (level: FacilityArea['accessLevel']): { variation: "info" | "warning" | "success", label: string } => {
    switch (level) {
      case 'all':
        return { variation: 'success', label: '一般利用可' };
      case 'authorized':
        return { variation: 'info', label: '許可制' };
      case 'restricted':
        return { variation: 'warning', label: '制限区域' };
    }
  };
 
  return (
    <View padding={tokens.space.large}>
      <ContentSection
        title="施設案内"
        description="Laboratory Alsarejiaの各施設・設備に関する案内です。"
      >
        <ToggleButtonGroup
          value={activeCategory}
          isExclusive
          onChange={(value) => setActiveCategory(value as FacilityArea['category'])}
          backgroundColor={tokens.colors.background.secondary}
          borderRadius="medium"
          padding="small"
        >
          <ToggleButton value="research">研究施設</ToggleButton>
          <ToggleButton value="observation">観測施設</ToggleButton>
          <ToggleButton value="analysis">解析施設</ToggleButton>
          <ToggleButton value="common">共用施設</ToggleButton>
        </ToggleButtonGroup>
 
        <Collection
          type="grid"
          items={facilityAreas.filter(area => area.category === activeCategory)}
          gap={tokens.space.medium}
          templateColumns={{
            base: "1fr",
            medium: "1fr 1fr"
          }}
        >
          {(area) => (
            <Card
              key={area.id}
              padding={tokens.space.medium}
              variation="elevated"
              onClick={() => setSelectedFacility(area)}
              style={{ cursor: 'pointer' }}
            >
              <Flex direction="column" gap="medium">
                {area.imagePath && (
                  <Image
                    src={area.imagePath}
                    alt={area.name}
                    width="100%"
                    height="200px"
                    objectFit="cover"
                    borderRadius="medium"
                  />
                )}
 
                <Flex justifyContent="space-between" alignItems="center">
                  <Heading level={3}>{area.name}</Heading>
                  <Badge 
                    variation={getAccessLevelConfig(area.accessLevel).variation}
                  >
                    {getAccessLevelConfig(area.accessLevel).label}
                  </Badge>
                </Flex>
 
                <Text>{area.description}</Text>
 
                <View backgroundColor={tokens.colors.background.secondary} padding="medium" borderRadius="small">
                  <Text fontWeight="bold" marginBottom="small">主要設備:</Text>
                  {area.features.map((feature, index) => (
                    <Text key={index} fontSize="small">• {feature}</Text>
                  ))}
                </View>
              </Flex>
            </Card>
          )}
        </Collection>
      </ContentSection>
 
      <DetailModal
        isOpen={!!selectedFacility}
        onClose={() => setSelectedFacility(null)}
        data={selectedFacility ? {
          id: selectedFacility.id,
          title: selectedFacility.name,
          description: selectedFacility.description,
          category: selectedFacility.category,
          imagePath: selectedFacility.imagePath,
          details: selectedFacility.details,
          metadata: {
            'アクセスレベル': getAccessLevelConfig(selectedFacility.accessLevel).label,
            '設備数': selectedFacility.features.length.toString()
          },
          tags: selectedFacility.features
        } : {
          id: '',
          title: '',
          description: '',
          category: '',
          tags: []
        }}
        entityType="facility"
      />
    </View>
  );
 };
```

### pages/laboratory/ObservationPage.tsx

```
// src/pages/laboratory/ObservationPage.tsx
import { 
  View, 
  Heading, 
  Collection,
  Card,
  Text,
  Badge,
  Flex,
  Button,
  useTheme,
  ToggleButtonGroup,
  ToggleButton
} from '@aws-amplify/ui-react';
import { ContentSection } from '../../components/common/ContentSection';
import { DetailModal } from '../../components/common/DetailModal';
import { useState } from 'react';

interface IdeaEntity {
  id: string;
  name: string;
  category: 'PHYSICAL' | 'MENTAL' | 'CONCEPTUAL';
  realityStrength: number;
  stabilityIndex: number;
  firstObservedAt: string;
  lastObservedAt: string;
  observationCount: number;
  status: 'stable' | 'unstable' | 'fluctuating';
  description: string;
  tags: string[];
  details?: {
    title: string;
    content: string;
  }[];
}

const mockIdeaEntities: IdeaEntity[] = [
  {
    id: 'idea-001',
    name: 'クリスタルメモリー',
    category: 'PHYSICAL',
    realityStrength: 0.75,
    stabilityIndex: 0.88,
    firstObservedAt: '2024-01-15',
    lastObservedAt: '2024-03-20',
    observationCount: 12,
    status: 'stable',
    description: '記憶を物質として結晶化させる現象。観測時の干渉により形状が変化する。',
    tags: ['結晶化', '記憶', '物質変容'],
    details: [
      {
        title: '基本特性',
        content: '記憶の結晶化現象は、特定の条件下で安定して観測されている。結晶の色や形状は、記憶の内容や強度によって変化する。'
      },
      {
        title: '観測履歴',
        content: '初回観測以降、12回の詳細な観測記録が存在。安定性は経時的に向上している。'
      }
    ]
  },
  // ... 他のモックデータ
];

export const ObservationPage = () => {
  const [activeCategory, setActiveCategory] = useState<IdeaEntity['category']>('PHYSICAL');
  const [selectedEntity, setSelectedEntity] = useState<IdeaEntity | null>(null);
  const { tokens } = useTheme();

  const RealityStrengthIndicator = ({ value }: { value: number }) => (
    <View
      backgroundColor={tokens.colors.background.secondary}
      padding="xxs"
      borderRadius="small"
      width="100px"
    >
      <View
        backgroundColor={
          value > 0.8 ? tokens.colors.green[60] :
          value > 0.5 ? tokens.colors.blue[60] :
          tokens.colors.red[60]
        }
        width={`${value * 100}%`}
        height="4px"
        borderRadius="small"
      />
    </View>
  );

  return (
    <View padding={tokens.space.large}>
      <ContentSection
        title="アイデア体観測システム"
        description="アイデア体の観測と記録を行うためのインターフェースです。"
      >
        <ToggleButtonGroup
          value={activeCategory}
          isExclusive
          onChange={(value) => setActiveCategory(value as IdeaEntity['category'])}
          backgroundColor={tokens.colors.background.secondary}
          borderRadius="medium"
          padding="small"
        >
          <ToggleButton value="PHYSICAL">物質形態</ToggleButton>
          <ToggleButton value="MENTAL">精神形態</ToggleButton>
          <ToggleButton value="CONCEPTUAL">概念形態</ToggleButton>
        </ToggleButtonGroup>

        <Button
          variation="primary"
          margin={tokens.space.medium}
        >
          + 新規アイデア体の登録
        </Button>

        <Collection
          type="grid"
          items={mockIdeaEntities.filter(entity => entity.category === activeCategory)}
          gap={tokens.space.medium}
          templateColumns={{
            base: "1fr",
            medium: "1fr 1fr"
          }}
        >
          {(entity) => (
            <Card
              key={entity.id}
              padding={tokens.space.medium}
              variation="elevated"
              onClick={() => setSelectedEntity(entity)}
              style={{ cursor: 'pointer' }}
            >
              <Flex direction="column" gap="small">
                <Flex justifyContent="space-between" alignItems="center">
                  <Heading level={3}>{entity.name}</Heading>
                  <Badge variation={
                    entity.status === 'stable' ? 'success' :
                    entity.status === 'unstable' ? 'error' :
                    'warning'
                  }>
                    {entity.status}
                  </Badge>
                </Flex>

                <Text>{entity.description}</Text>

                <Flex gap="small" alignItems="center">
                  <Text fontSize="small">現実性強度:</Text>
                  <RealityStrengthIndicator value={entity.realityStrength} />
                </Flex>

                <Flex gap="small" wrap="wrap">
                  {entity.tags.map(tag => (
                    <Badge key={tag} variation="info">{tag}</Badge>
                  ))}
                </Flex>

                <Flex justifyContent="space-between" fontSize="small">
                  <Text>観測回数: {entity.observationCount}</Text>
                  <Text>最終観測: {entity.lastObservedAt}</Text>
                </Flex>
              </Flex>
            </Card>
          )}
        </Collection>
      </ContentSection>

      <DetailModal
  isOpen={!!selectedEntity}
  onClose={() => setSelectedEntity(null)}
  data={selectedEntity ? {
    id: selectedEntity.id,
    title: selectedEntity.name,
    description: selectedEntity.description,
    category: selectedEntity.category,
    details: selectedEntity.details || [],
    metadata: {
      '現実性強度': `${selectedEntity.realityStrength * 100}%`,
      '安定性指数': `${selectedEntity.stabilityIndex * 100}%`,
      '観測回数': selectedEntity.observationCount.toString(),
      '初回観測': selectedEntity.firstObservedAt,
      '最終観測': selectedEntity.lastObservedAt
    },
    tags: selectedEntity.tags
  } : {
    id: '',
    title: '',
    description: '',
    category: '',
    tags: []
  }} // デフォルト値を提供
  entityType="idea"
/>
    </View>
  );
};
```

### pages/gallery/GalleryPage.tsx

```
// src/pages/gallery/GalleryPage.tsx
import { useEffect, useState } from 'react';
import {
  View,
  Heading,
  ToggleButtonGroup,
  ToggleButton,
  Collection,
  Button,
} from '@aws-amplify/ui-react';

import { AdvancedFilterPanel } from '../../components/common/AdvancedFilterPanel';
import { SkeletonList } from '../../components/common/SkeletonList';
import { ErrorAlert } from '../../components/common/ErrorAlert';
import { LibraryListViewItem } from '../../components/common/LibraryListViewItem';
import { ContentCard } from '../../components/common/ContentCard';
import { useInfiniteContents } from '../../hooks/useInfiniteContents';

interface GalleryItem {
  id: string;
  path: string;
  title: string;
  description?: string;
  category: string;
  tags: string[];
  isAvailable: boolean;
}

export const GalleryPage = () => {
  const [filterCondition, setFilterCondition] = useState({
    keyword: '',
    world: 'all',
    tags: [] as string[],
  });
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');

  const {
    items,
    loadMore,
    hasMore,
    loading,
    error,
    resetItems,
  } = useInfiniteContents();

  useEffect(() => {
    resetItems();
    loadMore({
      filter: {
        // e.g. category eq "illustration" など
      },
      limit: 6,
    });
  }, [filterCondition, resetItems, loadMore]);

  const mappedItems: GalleryItem[] = items.map((item) => ({
    id: item.id,
    path: '/images/sc.jpg',  // ダミー
    title: item.title ?? 'No Title',
    description: item.description,
    category: item.primaryCategory ?? 'illustration',
    tags: item.tags ?? [],
    isAvailable: true,
  }));

  return (
    <View width="100%" minHeight="100vh" padding="1rem">
      <Heading level={1} marginBottom="1rem">
        ギャラリー
      </Heading>

      <AdvancedFilterPanel
        availableTags={['キャラクター', '風景', 'Quxe', 'Alsarejia']}
        availableWorlds={['QUXE', 'HODEMEI', 'ALSAREJIA']}
        onChange={(newFilter) => setFilterCondition(newFilter)}
      />

      <ToggleButtonGroup
        value={viewMode}
        isExclusive
        onChange={(value) => setViewMode(value as 'grid' | 'list')}
        margin="1rem 0"
      >
        <ToggleButton value="grid">グリッド</ToggleButton>
        <ToggleButton value="list">リスト</ToggleButton>
      </ToggleButtonGroup>

      {error && <ErrorAlert errorMessage={error.message || 'エラーが発生しました'} onDismiss={() => {}} />}

      {loading && items.length === 0 ? (
        <SkeletonList count={4} />
      ) : (
        <>
          {viewMode === 'grid' && (
            <Collection
              type="grid"
              items={mappedItems}
              gap="medium"
              templateColumns={{
                base: '1fr',
                medium: '1fr 1fr',
                large: '1fr 1fr 1fr',
              }}
            >
              {(item) => (
                <ContentCard
                  key={item.id}
                  title={item.title}
                  description={item.description}
                  imagePath={item.path}
                  linkTo={`/gallery/view/${item.id}`}
                />
              )}
            </Collection>
          )}

          {viewMode === 'list' && (
            <Collection
              type="list"
              items={mappedItems}
              gap="small"
            >
              {(item) => (
                <LibraryListViewItem
                  key={item.id}
                  id={item.id}
                  title={item.title}
                  description={item.description}
                  isAvailable={item.isAvailable}
                  linkTo={`/gallery/view/${item.id}`}
                  category={item.category}
                  tags={item.tags}
                />
              )}
            </Collection>
          )}
        </>
      )}

      {hasMore && !loading && (
        <Button onClick={() => loadMore()} marginTop="1rem">
          さらに読み込む
        </Button>
      )}
      {loading && items.length > 0 && <SkeletonList count={2} />}
    </View>
  );
};
```

### pages/gallery/GalleryDetailPage.tsx

```
// src/pages/gallery/GalleryDetailPage.tsx
import { useParams, useNavigate } from 'react-router-dom';
import { View, Heading, Text, Image, Button, Flex } from '@aws-amplify/ui-react';
import { useState, useEffect } from 'react';

/** 仮のギャラリーデータ */
interface GalleryItem {
  id: string;
  title: string;
  imagePath: string;
  description?: string;
}

// ダミー一覧（本来はバックエンド連携やuseInfiniteContents()で取得）
const GALLERY_DATA: GalleryItem[] = [
  {
    id: 'sample1',
    title: 'サンプル画像1',
    imagePath: '/images/sc.jpg',
    description: 'テスト用のイメージです'
  },
  {
    id: 'sample2',
    title: 'サンプル画像2',
    imagePath: '/images/fallback.jpg',
    description: 'もうひとつのテスト用イメージ'
  }
];

export const GalleryDetailPage = () => {
  const { galleryId } = useParams();
  const navigate = useNavigate();
  const [item, setItem] = useState<GalleryItem | null>(null);

  useEffect(() => {
    // 仮: ダミーデータから検索
    const found = GALLERY_DATA.find((g) => g.id === galleryId);
    setItem(found || null);
  }, [galleryId]);

  if (!item) {
    return (
      <View padding="2rem" textAlign="center">
        <Heading level={3}>指定された画像が見つかりませんでした</Heading>
        <Button onClick={() => navigate('/gallery')} marginTop="1rem">
          ギャラリーへ戻る
        </Button>
      </View>
    );
  }

  return (
    <View padding="2rem" maxWidth="800px" margin="0 auto">
      <Button onClick={() => navigate('/gallery')} marginBottom="1rem">
        ← ギャラリー一覧に戻る
      </Button>

      <Flex direction="column" gap="medium" alignItems="center">
        <Heading level={2}>{item.title}</Heading>
        <Image
          src={item.imagePath}
          alt={item.title}
          objectFit="cover"
          width="100%"
          maxWidth="600px"
        />
        {item.description && (
          <Text>{item.description}</Text>
        )}
      </Flex>
    </View>
  );
};

```

### pages/admin/AdminDashboardPage.tsx

```
// src/pages/admin/AdminDashboardPage.tsx
import { View, Heading, Text, Button } from '@aws-amplify/ui-react';
import { useNavigate } from 'react-router-dom';

export const AdminDashboardPage = () => {
  const navigate = useNavigate();

  return (
    <View padding="2rem">
      <Heading level={2}>管理ダッシュボード</Heading>
      <Text marginTop="1rem">
        ここではユーザー管理やコンテンツ審査などの管理機能を行えます。
        （実際の機能は今後実装予定）
      </Text>

      <Button onClick={() => navigate('/') } marginTop="2rem">
        トップページへ戻る
      </Button>
    </View>
  );
};

```

### pages/library/SideStory.tsx

```
// src/pages/library/SideStory.tsx
import { 
  View, 
  Collection, 
  Card, 
  Text, 
  Button, 
  Heading,
  Flex,
  Badge,
  SelectField
} from '@aws-amplify/ui-react';
import { StoryViewer } from '../../components/content/StoryViewer';
import { useState } from 'react';
import { ContentSection } from '../../components/common/ContentSection';

interface SideStoryContent {
  id: string;
  title: string;
  summary: string;
  type: 'official' | 'shared';
  author: string;
  worldCategory: 'quxe' | 'hodemei' | 'alsarejia' | 'multiple';
  status: 'published' | 'ongoing' | 'coming_soon';
  totalChapters: number;
  currentChapter?: number;
  releaseDate: string;
  readingTime: number;
  hasInteractiveContent: boolean;
}

const sideStoryContents: SideStoryContent[] = [
  {
    id: 'quxe-researcher',
    title: '研究者の日記',
    summary: 'Quxeの世界を研究するために赴任してきた研究者の記録',
    type: 'official',
    author: 'サレジア',
    worldCategory: 'quxe',
    status: 'published',
    totalChapters: 3,
    currentChapter: 3,
    releaseDate: '2024-01-15',
    readingTime: 25,
    hasInteractiveContent: true
  },
  // 他のサイドストーリーをここに追加
];

export const SideStory = () => {
  const [selectedStory, setSelectedStory] = useState<SideStoryContent | null>(null);
  const [filter, setFilter] = useState<'all' | 'official' | 'shared'>('all');
  const [worldFilter, setWorldFilter] = useState<'all' | SideStoryContent['worldCategory']>('all');
  const [currentChapter, setCurrentChapter] = useState(1);

  const filteredStories = sideStoryContents.filter(story => 
    (filter === 'all' || story.type === filter) &&
    (worldFilter === 'all' || story.worldCategory === worldFilter)
  );

  const StoryMetadata = ({ story }: { story: SideStoryContent }) => (
    <Flex gap="small" wrap="wrap">
      <Badge variation={
        story.status === 'published' ? 'success' : 
        story.status === 'ongoing' ? 'info' : 
        'warning'
      }>
        {story.status === 'published' ? '完結' : 
         story.status === 'ongoing' ? '連載中' : 
         '近日公開'}
      </Badge>
      <Text fontSize="small" color="font.secondary">
        {`${story.currentChapter ?? 0}/${story.totalChapters}話`}
      </Text>
      <Text fontSize="small" color="font.secondary">
        {`読了時間: 約${story.readingTime}分`}
      </Text>
    </Flex>
  );

  return (
    <View>
      {selectedStory ? (
        <View>
          <Button 
            onClick={() => setSelectedStory(null)} 
            marginBottom="1rem"
            variation="link"
          >
            ← ストーリー一覧に戻る
          </Button>
          <StoryViewer
            storyPath={`library/sidestory/${selectedStory.type}/${selectedStory.id}`}
            currentChapter={currentChapter}
            totalChapters={selectedStory.totalChapters}
            onChapterChange={setCurrentChapter}
            metadata={{
              title: selectedStory.title,
              category: selectedStory.worldCategory,
              reference: selectedStory.type
            }}
            author={{
              name: selectedStory.author,
              showAuthor: true
            }}
          />
        </View>
      ) : (
        <ContentSection title="サイドストーリー">
          <Flex gap="medium" marginBottom="large">
            <SelectField
              label="表示フィルター"
              value={filter}
              onChange={e => setFilter(e.target.value as typeof filter)}
            >
              <option value="all">すべて表示</option>
              <option value="official">公式ストーリー</option>
              <option value="shared">共有ストーリー</option>
            </SelectField>

            <SelectField
              label="世界別フィルター"
              value={worldFilter}
              onChange={e => setWorldFilter(e.target.value as typeof worldFilter)}
            >
              <option value="all">すべての世界</option>
              <option value="quxe">Quxe</option>
              <option value="hodemei">Hodemei</option>
              <option value="alsarejia">Alsarejia</option>
              <option value="multiple">複数世界</option>
            </SelectField>
          </Flex>

          <Collection
            type="grid"
            items={filteredStories}
            gap="medium"
            templateColumns={{
              base: "1fr",
              medium: "1fr 1fr",
              large: "1fr 1fr 1fr"
            }}
          >
            {(story) => (
              <Card
                key={story.id}
                padding="1.5rem"
                variation="elevated"
                onClick={() => story.status !== 'coming_soon' && setSelectedStory(story)}
                style={{
                  cursor: story.status !== 'coming_soon' ? 'pointer' : 'default',
                  opacity: story.status !== 'coming_soon' ? 1 : 0.7
                }}
              >
                <Flex direction="column" gap="medium">
                  <Heading level={3}>{story.title}</Heading>
                  <Text color="font.secondary">{story.summary}</Text>
                  <Text fontSize="small">
                    作者: {story.author}
                  </Text>
                  <StoryMetadata story={story} />
                </Flex>
              </Card>
            )}
          </Collection>
        </ContentSection>
      )}
    </View>
  );
};
```

### pages/library/MainStory.tsx

```
// src/pages/library/MainStory.tsx
import { 
  View, 
  Collection, 
  Card, 
  Text, 
  Button, 
  Heading,
  Flex,
  Badge
} from '@aws-amplify/ui-react';
import { StoryViewer } from '../../components/content/StoryViewer';
import { useState } from 'react';
import { ContentSection } from '../../components/common/ContentSection';

interface StoryChapter {
  id: string;
  title: string;
  summary: string;
  chapterNumber: number;
  status: 'published' | 'coming_soon';
  releaseDate: string;
  readingTime: number;
  hasInteractiveContent: boolean;
}

const mainStoryChapters: StoryChapter[] = [
  {
    id: 'prologue',
    title: '研究記録0: 記憶の欠損',
    summary: '全ての始まり。研究所の構内で目覚めた私は自分の記憶を失っていた。\nそこで出会った不思議な存在、ニファーシェ。',
    chapterNumber: 0,
    status: 'published',
    releaseDate: '2024-01-01',
    readingTime: 15,
    hasInteractiveContent: true
  },
  {
    id: 'chapter1',
    title: '研究記録1: アイデア体の観測',
    summary: 'アイデア体の観測を開始する。創発的な世界の姿が少しずつ見えてきた。\n私たちが目指すべきものとは一体...？',
    chapterNumber: 1,
    status: 'published',
    releaseDate: '2024-02-01',
    readingTime: 20,
    hasInteractiveContent: true
  },
  {
    id: 'chapter2',
    title: '研究記録2: 境界の探索',
    summary: '現実と想像の境界線上で、私たちは何を見出すのか。\n研究は新たな段階へと進む...',
    chapterNumber: 2,
    status: 'coming_soon',
    releaseDate: '2024-04-01',
    readingTime: 25,
    hasInteractiveContent: true
  }
];

export const MainStory = () => {
  const [selectedChapter, setSelectedChapter] = useState<StoryChapter | null>(null);

  const ChapterStatus = ({ chapter }: { chapter: StoryChapter }) => (
    <Flex gap="small" wrap="wrap" alignItems="center">
      <Badge variation={chapter.status === 'published' ? 'success' : 'warning'}>
        {chapter.status === 'published' ? '公開中' : '近日公開'}
      </Badge>
      <Text fontSize="small" color="font.secondary">
        {`読了時間: 約${chapter.readingTime}分`}
      </Text>
      {chapter.hasInteractiveContent && (
        <Badge variation="info">対話型コンテンツ</Badge>
      )}
      <Text fontSize="small" color="font.tertiary">
        公開日: {chapter.releaseDate}
      </Text>
    </Flex>
  );

  return (
    <View>
      {selectedChapter ? (
        <View>
          <Button 
            onClick={() => setSelectedChapter(null)} 
            marginBottom="1rem"
            variation="link"
          >
            ← チャプター一覧に戻る
          </Button>
          <StoryViewer
            storyPath={`library/mainstory/${selectedChapter.id}`}
            currentChapter={selectedChapter.chapterNumber}
            totalChapters={mainStoryChapters.length}
            onChapterChange={(chapter) => {
              const nextChapter = mainStoryChapters.find(c => c.chapterNumber === chapter);
              if (nextChapter && nextChapter.status === 'published') {
                setSelectedChapter(nextChapter);
              }
            }}
            metadata={{
              title: selectedChapter.title,
              reference: `MST-${selectedChapter.chapterNumber.toString().padStart(3, '0')}`
            }}
          />
        </View>
      ) : (
        <ContentSection
          title="メインストーリー"
          description="サレジアとニファーシェが紡ぐ物語。現実と想像の境界で、私たちは何を見出すのか。"
        >
          <Collection
            type="grid"
            items={mainStoryChapters}
            gap="medium"
            templateColumns={{
              base: "1fr",
              medium: "1fr 1fr"
            }}
          >
            {(chapter) => (
              <Card
                key={chapter.id}
                padding="1.5rem"
                variation="elevated"
                onClick={() => chapter.status === 'published' && setSelectedChapter(chapter)}
                style={{
                  cursor: chapter.status === 'published' ? 'pointer' : 'default',
                  opacity: chapter.status === 'published' ? 1 : 0.7
                }}
              >
                <Flex direction="column" gap="medium">
                  <Heading level={3}>{chapter.title}</Heading>
                  <Text 
                    color="font.secondary"
                    style={{ whiteSpace: 'pre-line' }}
                  >
                    {chapter.summary}
                  </Text>
                  <ChapterStatus chapter={chapter} />
                </Flex>
              </Card>
            )}
          </Collection>
        </ContentSection>
      )}
    </View>
  );
};
```

### pages/library/LibraryOverviewPage.tsx

```
// src/pages/library/LibraryOverviewPage.tsx
import { useEffect, useState } from 'react';
import { View, Heading, Collection, Button, ToggleButtonGroup, ToggleButton } from '@aws-amplify/ui-react';
import { AdvancedFilterPanel } from '../../components/common/AdvancedFilterPanel';
import { SkeletonList } from '../../components/common/SkeletonList';
import { ErrorAlert } from '../../components/common/ErrorAlert';
import { LibraryListViewItem } from '../../components/common/LibraryListViewItem';
import { ContentCard } from '../../components/common/ContentCard'; // or any other card
import { useInfiniteContents } from '../../hooks/useInfiniteContents';

interface StoryOverview {
  id: string;
  title: string;
  description: string;
  status: string;
  thumbnailPath: string;
  isAvailable: boolean;
}

export const LibraryOverviewPage = () => {
  const [filterCondition, setFilterCondition] = useState({
    keyword: '',
    world: 'all',
    tags: [] as string[],
  });
  const [viewMode, setViewMode] = useState<'grid' | 'list'>('grid');

  const {
    items,
    loadMore,
    hasMore,
    loading,
    error,
    resetItems,
  } = useInfiniteContents();

  useEffect(() => {
    resetItems();
    loadMore({
      filter: {
        // 例: primaryCategory eq "MAIN_STORY" or "SIDE_STORY"
      },
      limit: 6,
    });
  }, [filterCondition, resetItems, loadMore]);

  const mappedItems: StoryOverview[] = items.map((item) => ({
    id: item.id,
    title: item.title ?? 'No Title',
    description: item.description ?? '',
    status: item.status ?? 'ongoing',
    thumbnailPath: '/images/main-story.jpg',
    isAvailable: true,
  }));

  return (
    <View padding="1rem">
      <Heading level={2} marginBottom="1rem">
        Library Overview
      </Heading>

      <AdvancedFilterPanel
        availableTags={['メイン', 'サイド', '研究']}
        availableWorlds={['QUXE', 'HODEMEI', 'ALSAREJIA']}
        onChange={(newFilter) => setFilterCondition(newFilter)}
      />

      <ToggleButtonGroup
        value={viewMode}
        isExclusive
        onChange={(value) => setViewMode(value as 'grid' | 'list')}
        margin="1rem 0"
      >
        <ToggleButton value="grid">グリッド</ToggleButton>
        <ToggleButton value="list">リスト</ToggleButton>
      </ToggleButtonGroup>

      {error && <ErrorAlert errorMessage={error.message || 'エラーが発生しました'} onDismiss={() => {}} />}

      {loading && items.length === 0 ? (
        <SkeletonList count={4} />
      ) : (
        <>
          {viewMode === 'grid' && (
            <Collection
              type="grid"
              items={mappedItems}
              gap="medium"
              templateColumns={{
                base: '1fr',
                medium: '1fr 1fr',
                large: '1fr 1fr 1fr',
              }}
            >
              {(item) => (
                <ContentCard
                  key={item.id}
                  title={item.title}
                  description={item.description}
                  imagePath={item.thumbnailPath}
                  linkTo={`/library/${item.id}`}
                />
              )}
            </Collection>
          )}

          {viewMode === 'list' && (
            <Collection type="list" items={mappedItems} gap="small">
              {(item) => (
                <LibraryListViewItem
                  key={item.id}
                  id={item.id}
                  title={item.title}
                  description={item.description}
                  isAvailable={item.isAvailable}
                  linkTo={`/library/${item.id}`}
                />
              )}
            </Collection>
          )}
        </>
      )}

      {hasMore && !loading && (
        <Button onClick={() => loadMore()} marginTop="1rem">
          さらに読み込む
        </Button>
      )}
      {loading && items.length > 0 && <SkeletonList count={2} />}
    </View>
  );
};

```

### pages/library/RecordsPage.tsx

```
// src/pages/library/RecordsPage.tsx
import { useState } from 'react';
import { View, Heading, Collection, Card, Text, Badge, Flex, Button } from '@aws-amplify/ui-react';
import { useNavigate } from 'react-router-dom';

interface RecordItem {
  id: string;
  title: string;
  description: string;
  category: 'theory' | 'experiment' | 'observation' | 'misc';
  status: 'open' | 'closed';
  date: string;
}

const mockRecords: RecordItem[] = [
  {
    id: 'r-001',
    title: 'アイデア体の共鳴現象',
    description: '複数のアイデア体を同時観測した際の共鳴現象研究ノート',
    category: 'experiment',
    status: 'open',
    date: '2024-03-10'
  },
  {
    id: 'r-002',
    title: '境界領域に関する考察',
    description: '現実と想像の狭間における不思議な干渉のレポート',
    category: 'theory',
    status: 'closed',
    date: '2024-02-28'
  }
];

export const RecordsPage = () => {
  const [filter, setFilter] = useState<'all' | 'open' | 'closed'>('all');
  const navigate = useNavigate();

  const filtered = mockRecords.filter(rec => {
    if (filter === 'all') return true;
    return rec.status === filter;
  });

  return (
    <View padding="2rem">
      <Heading level={1} marginBottom="1rem">
        研究記録集
      </Heading>
      <Text marginBottom="1rem">
        Laboratoryで記録された研究データや実験結果を閲覧できます。
      </Text>

      <Flex gap="small" marginBottom="1rem">
        <Button
          onClick={() => setFilter('all')}
          variation={filter === 'all' ? 'primary' : 'link'}
        >
          全て
        </Button>
        <Button
          onClick={() => setFilter('open')}
          variation={filter === 'open' ? 'primary' : 'link'}
        >
          公開中
        </Button>
        <Button
          onClick={() => setFilter('closed')}
          variation={filter === 'closed' ? 'primary' : 'link'}
        >
          閲覧終了
        </Button>
      </Flex>

      <Collection type="list" items={filtered} gap="small">
        {(item) => (
          <Card key={item.id} variation="elevated" padding="1rem">
            <Flex direction="column" gap="xsmall">
              <Heading level={3}>{item.title}</Heading>
              <Text>{item.description}</Text>
              <Flex gap="small" alignItems="center">
                <Badge variation={item.status === 'open' ? 'success' : 'warning'}>
                  {item.status === 'open' ? '公開中' : '閲覧終了'}
                </Badge>
                <Badge variation="info">{item.category}</Badge>
                <Text fontSize="small" color="font.tertiary">
                  {item.date}
                </Text>
              </Flex>
            </Flex>
          </Card>
        )}
      </Collection>

      <Button onClick={() => navigate('/library')} marginTop="2rem" variation="link">
        ライブラリトップへ戻る
      </Button>
    </View>
  );
};

```

### pages/library/SideStoryListPage.tsx

```
// src/pages/library/SideStoryListPage.tsx
import { useState } from 'react';
import { 
  Collection, 
  Card, 
  Text, 
  Heading,
  Flex,
  Badge,
  SelectField,
  useTheme,
  Button
} from '@aws-amplify/ui-react';
import { useNavigate } from 'react-router-dom';
import { ContentSection } from '../../components/common/ContentSection';

// SideStoryの型
interface SideStoryContent {
  id: string;
  title: string;
  summary: string;
  type: 'official' | 'shared';
  author: string;
  worldCategory: string;
  status: 'published' | 'ongoing' | 'coming_soon';
  totalChapters: number;
  currentChapter?: number;
  releaseDate: string;
  readingTime: number;
  hasInteractiveContent: boolean;
}

// ダミーデータ
const sideStoryContents: SideStoryContent[] = [
  {
    id: 'quxe-researcher',
    title: '研究者の日記',
    summary: 'Quxeの世界を研究するために赴任してきた研究者の記録',
    type: 'official',
    author: 'サレジア',
    worldCategory: 'quxe',
    status: 'published',
    totalChapters: 3,
    currentChapter: 3,
    releaseDate: '2024-01-15',
    readingTime: 25,
    hasInteractiveContent: true
  },
];

export const SideStoryListPage = () => {
  const { tokens } = useTheme();
  const navigate = useNavigate();

  const [filter, setFilter] = useState<'all' | 'official' | 'shared'>('all');
  const [worldFilter, setWorldFilter] = useState<'all' | string>('all');

  const filteredStories = sideStoryContents.filter(story => 
    (filter === 'all' || story.type === filter) &&
    (worldFilter === 'all' || story.worldCategory === worldFilter)
  );

  return (
    <ContentSection title="サイドストーリー" description="様々な世界観・作者による短編や番外編を集めています。">
      <Flex gap="medium" marginBottom="large">
        <SelectField
          label="表示フィルター"
          value={filter}
          onChange={(e) => setFilter(e.target.value as typeof filter)}
        >
          <option value="all">すべて表示</option>
          <option value="official">公式ストーリー</option>
          <option value="shared">共有ストーリー</option>
        </SelectField>

        <SelectField
          label="世界別フィルター"
          value={worldFilter}
          onChange={(e) => setWorldFilter(e.target.value as typeof worldFilter)}
        >
          <option value="all">すべての世界</option>
          <option value="quxe">Quxe</option>
          <option value="hodemei">Hodemei</option>
          <option value="alsarejia">Alsarejia</option>
          <option value="multiple">複数世界</option>
        </SelectField>
      </Flex>

      <Collection
        type="grid"
        items={filteredStories}
        gap={tokens.space.medium}
        templateColumns={{
          base: "1fr",
          medium: "1fr 1fr",
          large: "1fr 1fr 1fr"
        }}
      >
        {(story) => (
          <Card
            key={story.id}
            padding="1.5rem"
            variation="elevated"
            style={{
              cursor: story.status !== 'coming_soon' ? 'pointer' : 'default',
              opacity: story.status !== 'coming_soon' ? 1 : 0.7
            }}
          >
            <Flex direction="column" gap="medium">
              <Heading level={3}>{story.title}</Heading>
              <Text color="font.secondary">{story.summary}</Text>
              <Text fontSize="small">作者: {story.author}</Text>
              
              <Flex gap="small" wrap="wrap">
                <Badge variation={
                  story.status === 'published' ? 'success' :
                  story.status === 'ongoing' ? 'info' : 
                  'warning'
                }>
                  {story.status === 'published' ? '完結' : 
                   story.status === 'ongoing' ? '連載中' : 
                   '近日公開'}
                </Badge>
                <Text fontSize="small" color="font.secondary">
                  {`${story.currentChapter ?? 0}/${story.totalChapters}話`}
                </Text>
              </Flex>

              {story.status !== 'coming_soon' && (
                <Button
                  onClick={() => navigate(`/library/sidestory/detail/${story.id}`)}
                  variation="link"
                  size="small"
                >
                  詳細を見る
                </Button>
              )}
            </Flex>
          </Card>
        )}
      </Collection>
    </ContentSection>
  );
};

```

### pages/library/SideStoryDetailPage.tsx

```
// src/pages/library/SideStoryDetailPage.tsx
import React, { useMemo } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { View, Heading, Button} from '@aws-amplify/ui-react';
import { StoryViewer } from '../../components/content/StoryViewer';

/**
 * サイドストーリーの詳細ページ例。
 * ルート: /library/sidestory/detail/:storyId
 * 
 * ここではダミーデータのみを用意。
 */
const DUMMY_STORIES = [
  {
    id: 'quxe-researcher',
    title: '研究者の日記',
    author: 'サレジア',
    totalChapters: 3
  }
];

export const SideStoryDetailPage: React.FC = () => {
  const { storyId } = useParams();
  const navigate = useNavigate();

  // ダミー検索
  const story = useMemo(() => DUMMY_STORIES.find(s => s.id === storyId), [storyId]);

  if (!story) {
    return (
      <View padding="2rem">
        <Heading level={3}>ストーリーが見つかりません</Heading>
        <Button onClick={() => navigate('/library/sidestory')}>
          一覧に戻る
        </Button>
      </View>
    );
  }

  return (
    <View padding="2rem">
      <Button 
        onClick={() => navigate('/library/sidestory')} 
        variation="link"
        marginBottom="1rem"
      >
        ← サイドストーリー一覧に戻る
      </Button>

      <StoryViewer
        // 例: pathは "/library/sidestory/official/quxe-researcher"
        // ここでは簡易的に仮パス
        storyPath={`library/sidestory/official/${story.id}`}
        currentChapter={1}
        totalChapters={story.totalChapters}
        metadata={{
          title: story.title,
          category: 'Quxe',
          reference: 'official'
        }}
        author={{
          name: story.author,
          showAuthor: true
        }}
      />
    </View>
  );
};

```

### pages/library/LibraryPage.tsx

```
// src/pages/library/LibraryPage.tsx
import { 
  View, 
  Collection,
  useTheme 
} from '@aws-amplify/ui-react';
import { ContentCard } from '../../components/common/ContentCard';
import { ContentSection } from '../../components/common/ContentSection';

const sections = [
  {
    id: 'mainstory',
    title: 'メインストーリー',
    description: 'サレジアとニファーシェの物語',
    path: '/library/mainstory',
    image: '/images/main-story.jpg'
  },
  {
    id: 'sidestory',
    title: 'サイドストーリー',
    description: '様々な視点から描かれる物語群',
    path: '/library/sidestory',
    image: '/images/side-story.jpg'
  },
  {
    id: 'records',
    title: '研究記録集',
    description: 'アイデア体の観測記録と考察',
    path: '/library/records',
    image: '/images/records.jpg'
  }
];

export const LibraryPage = () => {
  const { tokens } = useTheme();

  return (
    <View padding={tokens.space.large}>
      <ContentSection
        title="Library"
        description="Project Nifercheの世界観を紡ぐ物語と記録"
      >
        <Collection
          type="grid"
          items={sections}
          gap={tokens.space.medium}
          templateColumns={{
            base: "1fr",
            medium: "1fr 1fr",
            large: "1fr 1fr 1fr"
          }}
        >
          {(item) => (
            <ContentCard
              key={item.id}
              title={item.title}
              description={item.description}
              imagePath={item.image}
              linkTo={item.path}
            />
          )}
        </Collection>
      </ContentSection>
    </View>
  );
};
```

### pages/user/ProfilePage.tsx

```
// src/pages/user/ProfilePage.tsx
import { View, Heading, Text, Button, Card } from '@aws-amplify/ui-react';
import { useSession } from '../../contexts/SessionContext';
import { useState } from 'react';

export const ProfilePage = () => {
  const { isSignedIn, user } = useSession();
  const [isEditing, setIsEditing] = useState(false);

  // ログインしてなければ ProtectedRoute で弾かれるはずだが
  // 念のため fallback
  if (!isSignedIn) {
    return <Text>ログインが必要です</Text>;
  }

  // user?.attributes から各種属性を取り出す
  const username = user?.username;
  const email = user?.attributes?.email;
  const role = user?.attributes?.['custom:role'];

  return (
    <View padding="medium">
      <Card>
        <Heading level={2}>プロフィールページ</Heading>

        <View padding="medium">
          <Text>ユーザー名: {username}</Text>
          <Text>メールアドレス: {email}</Text>
          <Text>ロール: {role ?? 'user'}</Text>
        </View>

        {isEditing ? (
          <Button onClick={() => setIsEditing(false)}>編集をキャンセル</Button>
        ) : (
          <Button onClick={() => setIsEditing(true)}>プロフィールを編集</Button>
        )}
      </Card>
    </View>
  );
};
```

### pages/user/FavoritesPage.tsx

```
// src/pages/user/FavoritesPage.tsx
import { 
    View, 
    Heading, 
    Collection, 
    Card,
    Text
  } from '@aws-amplify/ui-react';
  import { Navigate } from 'react-router-dom';
  import { useSession } from '../../contexts/SessionContext';
  interface FavoriteItem {
    id: string;
    title: string;
    type: string;
  }
  
  export const FavoritesPage = () => {
    const { isSignedIn } = useSession();
  
    if (!isSignedIn) {
      return <Navigate to="/auth/signin" />;
    }
  
    // サンプルデータ（実際にはバックエンドから取得）
    const sampleFavorites: FavoriteItem[] = [
      { id: '1', title: 'サンプルコンテンツ1', type: 'story' },
      { id: '2', title: 'サンプルコンテンツ2', type: 'idea' }
    ];
  
    return (
      <View padding="medium">
        <Heading level={2}>お気に入り</Heading>
        <Collection
          type="grid"
          items={sampleFavorites}
          gap="medium"
          templateColumns={{
            base: "1fr",
            medium: "1fr 1fr"
          }}
        >
          {(item: FavoriteItem) => (
            <Card key={item.id}>
              <Text>{item.title}</Text>
              <Text fontSize="small">タイプ: {item.type}</Text>
            </Card>
          )}
        </Collection>
      </View>
    );
  };
```

### pages/ErrorPage.tsx

```
// src/pages/error/ErrorPage.tsx
import { View, Heading, Text, Button } from '@aws-amplify/ui-react';
import { useNavigate } from 'react-router-dom';

export const ErrorPage = () => {
  const navigate = useNavigate();

  return (
    <View 
      padding="2rem"
      textAlign="center"
      maxWidth="600px"
      margin="0 auto"
    >
      <Heading level={1}>エラーが発生しました</Heading>
      <Text>
        申し訳ありません。予期せぬエラーが発生しました。
      </Text>
      <Button
        onClick={() => navigate('/')}
        variation="primary"
      >
        メインページに戻る
      </Button>
    </View>
  );
};
```

### pages/system/auth/ConfirmSignUpPage.tsx

```
// src/pages/system/auth/ConfirmSignUpPage.tsx
import { useState, useEffect } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import { 
  View, 
  Heading, 
  TextField, 
  Button, 
  Text,
  Alert
} from '@aws-amplify/ui-react';

export const ConfirmSignUpPage = () => {
  const [code, setCode] = useState('');
  const [error] = useState('');
  const navigate = useNavigate();
  const location = useLocation();

  useEffect(() => {
    const state = location.state as { username?: string };
    if (!state?.username) {
      // ユーザ名がない → サインアップ画面へ戻す
      navigate('/auth/signup');
    }
  }, [location, navigate]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    // モックバージョンでは確認成功をシミュレート
    navigate('/auth/signin', {
      state: { message: 'アカウントが確認されました。サインインしてください。' }
    });
  };

  return (
    <View padding="medium">
      <Heading level={2}>アカウント確認</Heading>
      <Text>
        確認コードをメールアドレスに送信しました。
        コードを入力してアカウントを有効化してください。
      </Text>
      {error && <Alert variation="error">{error}</Alert>}
      <form onSubmit={handleSubmit}>
        <TextField
          label="確認コード"
          value={code}
          onChange={(e) => setCode(e.target.value)}
          required
        />
        <Button type="submit" variation="primary">
          確認
        </Button>
      </form>
      <Text>
        コードが届かない場合は
        <Button
          variation="link"
          onClick={() => navigate('/auth/signup')}
        >
          アカウント作成をやり直す
        </Button>
      </Text>
      <View marginTop="1rem">
        <Alert variation="info">
          これはモックページです。任意のコードを入力してください。
        </Alert>
      </View>
    </View>
  );
};
```

### pages/system/auth/SignInPage.tsx

```
// src/pages/system/auth/SignInPage.tsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
  View, 
  Heading, 
  TextField, 
  Button, 
  Text,
  Alert
} from '@aws-amplify/ui-react';
import { useSession } from '../../../contexts/SessionContext';

export const SignInPage = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const navigate = useNavigate();
  const { login } = useSession();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const success = await login(username, password);
      if (success) {
        navigate('/');
      } else {
        setError('ログインに失敗しました。ユーザー名とパスワードを確認してください。');
      }
    } catch (error: any) {
      setError(error.message || 'Unknown error');
    }
  };

  return (
    <View padding="medium">
      <Heading level={2}>サインイン</Heading>
      {error && <Alert variation="error">{error}</Alert>}
      <form onSubmit={handleSubmit}>
        <TextField
          label="ユーザー名"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          required
        />
        <TextField
          label="パスワード"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
        <Button type="submit" variation="primary">
          サインイン
        </Button>
      </form>
      <Text>
        アカウントをお持ちでない方は
        <Button
          variation="link"
          onClick={() => navigate('/auth/signup')}
        >
          新規登録
        </Button>
      </Text>
      <View marginTop="1rem">
        <Alert variation="info">
          テスト用アカウント:<br />
          管理者: username=admin, password=password<br />
          一般: username=user, password=password
        </Alert>
      </View>
    </View>
  );
};
```

### pages/system/auth/SignUpPage.tsx

```
// src/pages/system/auth/SignUpPage.tsx
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { 
  View, 
  Heading, 
  TextField, 
  Button, 
  Text,
  Alert
} from '@aws-amplify/ui-react';

export const SignUpPage = () => {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [error, setError] = useState('');
  const navigate = useNavigate();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    if (password !== confirmPassword) {
      setError('パスワードが一致しません');
      return;
    }
    
    // モックバージョンではサインアップをシミュレート
    setError('現在、新規登録機能は利用できません。テスト用アカウントをご利用ください。');
  };

  return (
    <View padding="medium">
      <Heading level={2}>アカウント作成</Heading>
      {error && <Alert variation="error">{error}</Alert>}
      <form onSubmit={handleSubmit}>
        <TextField
          label="ユーザー名"
          value={username}
          onChange={(e) => setUsername(e.target.value)}
          required
        />
        <TextField
          label="メールアドレス"
          type="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
          required
        />
        <TextField
          label="パスワード"
          type="password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
          required
        />
        <TextField
          label="パスワード（確認）"
          type="password"
          value={confirmPassword}
          onChange={(e) => setConfirmPassword(e.target.value)}
          required
        />
        <Button type="submit" variation="primary">
          アカウント作成
        </Button>
      </form>
      <Text>
        すでにアカウントをお持ちの方は
        <Button
          variation="link"
          onClick={() => navigate('/auth/signin')}
        >
          サインイン
        </Button>
      </Text>
      <View marginTop="1rem">
        <Alert variation="info">
          テスト用アカウント:<br />
          管理者: username=admin, password=password<br />
          一般: username=user, password=password
        </Alert>
      </View>
    </View>
  );
};
```

### pages/system/TermsPage.tsx

```
import { View, Heading, Text, Divider, Flex } from '@aws-amplify/ui-react';

export const TermsPage = () => {
  return (
    <View padding="medium" maxWidth="800px" margin="0 auto">
      <Flex direction="column" gap="large">
        <Heading level={1}>利用規約</Heading>
        <Text>
          この利用規約（以下「本規約」）は、Project Niferche（以下「当プロジェクト」）が提供するウェブサイトおよびサービス（以下「本サービス」）の利用条件を定めるものです。
        </Text>

        <Section
          title="1. 適用"
          content="本規約は、本サービスの利用に関する当プロジェクトとユーザーとの間の権利義務関係を定めることを目的とし、ユーザーと当プロジェクトとの間の本サービスの利用に関わる一切の関係に適用されます。"
        />

        <Section
          title="2. 知的財産権"
          content={`当プロジェクトが提供する全てのコンテンツ（文章、画像、デザイン、ロゴ等を含む）に関する知的財産権は、当プロジェクトまたは当プロジェクトにライセンスを許諾している者に帰属します。\n
ユーザーは、当プロジェクトの明示的な許可なく、これらのコンテンツを複製、転載、改変、二次利用することはできません。`}
        />

        <Section
          title="3. 設定資料の利用"
          content={`当プロジェクトが提供する設定資料は、以下の条件下で利用可能です：\n
・非商用の創作活動における参照および利用\n
・出典の明記\n
・当プロジェクトの世界観を著しく損なわない形での利用`}
        />

        <Section
          title="4. ユーザー投稿"
          content={`ユーザーが本サービスに投稿したコンテンツの著作権はユーザーに帰属します。\n
ただし、ユーザーは当プロジェクトに対し、投稿コンテンツを本サービスの提供、改善、宣伝のために利用する権利を許諾するものとします。`}
        />

        <Section
          title="5. 禁止事項"
          content={`以下の行為を禁止します：\n
・法令または公序良俗に違反する行為\n
・当プロジェクトまたは第三者の知的財産権を侵害する行為\n
・本サービスの運営を妨害する行為\n
・その他、当プロジェクトが不適切と判断する行為`}
        />

        <Section
          title="6. 免責事項"
          content="当プロジェクトは、本サービスの内容の正確性、完全性、有用性、安全性等について、いかなる保証も行うものではありません。"
        />

        <Section
          title="7. 規約の変更"
          content="当プロジェクトは、必要と判断した場合には、ユーザーに通知することなく本規約を変更することができるものとします。"
        />

        <View marginTop="xxl">
          <Text variation="tertiary">
            最終更新日: 2024年11月24日
          </Text>
        </View>
      </Flex>
    </View>
  );
};

interface SectionProps {
  title: string;
  content: string;
}

const Section: React.FC<SectionProps> = ({ title, content }) => (
  <View>
    <Heading level={2} fontSize="large">{title}</Heading>
    <Divider marginBlock="medium" />
    <Text whiteSpace="pre-wrap">{content}</Text>
  </View>
);

```

### pages/system/GuidelinesPage.tsx

```
// src/pages/system/GuidelinesPage.tsx
import { View, Heading, Text, Divider, Flex, Button } from '@aws-amplify/ui-react';
import { useNavigate } from 'react-router-dom';

export const GuidelinesPage = () => {
  const navigate = useNavigate();
  
  return (
    <View padding="medium" maxWidth="800px" margin="0 auto">
      <Heading level={1}>ガイドライン</Heading>
      <Divider marginBlock="medium" />

      <Text>
        ここでは、Project Niferche内で創作活動や投稿を行うにあたってのガイドラインを示します。
        ユーザーの皆様に安心して活動いただくために、以下の点をご一読ください。
      </Text>

      <Flex direction="column" gap="medium" marginTop="1.5rem">
        <Section
          title="1. 投稿コンテンツに関して"
          content={`公序良俗に反する表現、極端に攻撃的な言動はお控えください。二次創作などを行う場合は、原著作者の権利を尊重しましょう。`}
        />

        <Section
          title="2. コミュニティマナー"
          content={`コメント欄やフォーラムでは他者の意見を尊重し、建設的な議論を行ってください。誹謗中傷や荒らし行為は警告やアカウント停止の対象となります。`}
        />

        <Section
          title="3. 二次利用規約"
          content={`公式コンテンツを含む作品を使用する際は、必ず出典を明記し、改変がある場合は改変箇所を明確に示してください。`}
        />

        <Section
          title="4. 運営ポリシー"
          content={`運営チームは、投稿内容が本ガイドラインに反すると判断した場合、投稿を削除する権利を有します。重大な違反にはアカウント停止等の措置を取ることがあります。`}
        />
      </Flex>

      <Divider marginBlock="medium" />

      <Button onClick={() => navigate('/call/philosophy')} variation="link">
        戻る
      </Button>
    </View>
  );
};

const Section = ({ title, content }: { title: string; content: string }) => (
  <View marginBottom="1rem">
    <Heading level={2} fontSize="large">{title}</Heading>
    <Text whiteSpace="pre-wrap" marginTop="small">
      {content}
    </Text>
  </View>
);

```

### pages/system/RightsPage.tsx

```
import { View, Heading, Text, Divider, Flex } from '@aws-amplify/ui-react';

export const RightsPage = () => {
  return (
    <View padding="medium" maxWidth="800px" margin="0 auto">
      <Flex direction="column" gap="large">
        <Heading level={1}>権利表記</Heading>
        
        <Section
          title="著作権について"
          content={`Project Niferche（当プロジェクト）で公開される全てのコンテンツ（文章、画像、音楽、プログラム等）の著作権は、特に明記がない限り当プロジェクトに帰属します。\n
各コンテンツの著作権者および制作者については、コンテンツ詳細ページにて個別に記載されています。`}
        />

        <Section
          title="コンテンツの利用について"
          content={`当プロジェクトのコンテンツは、以下のカテゴリに分類されます：\n
1. 公式コンテンツ
・メインストーリー、公式サイドストーリー
・公式設定資料、イラスト等
・プロジェクトロゴ、キャラクターデザイン等

2. 共有（Shared）コンテンツ
・ユーザー投稿によるサイドストーリー
・ユーザー作成の設定資料、イラスト等

各カテゴリの利用規約は以下の通りです。`}
        />

        <Section
          title="公式コンテンツの利用規約"
          content={`以下の条件を遵守する限り、商用・非商用目的を問わず利用を許可します：\n
1. 出典の明記
2. コンテンツの改変を行う場合、オリジナルとの区別を明確にすること
3. 公序良俗に反する利用を行わないこと
4. 当プロジェクトの信用を損なう利用を行わないこと
`}
        />

        <Section
          title="共有（Shared）コンテンツの利用規約"
          content={`共有コンテンツは、Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License（CC BY-NC-SA 4.0）に基づいて提供されます。\n
主な条件：
1. 作品のクレジットを表示すること
2. 営利目的での利用を行わないこと
3. 改変した場合、同じライセンスで公開すること`}
        />

        <Section
          title="免責事項"
          content={`当プロジェクトのコンテンツを利用したことによって生じたいかなる損害についても、当プロジェクトは責任を負いません。\n
コンテンツの利用者は、自己の責任において利用するものとします。`}
        />

        <Section
          title="権利侵害に関する申し立て"
          content="当プロジェクトのコンテンツが著作権その他の権利を侵害していると思われる場合は、お問い合わせフォームよりご連絡ください。適切な対応を取らせていただきます。"
        />

        <View marginTop="xxl">
          <Text variation="tertiary">
            最終更新日: 2024年11月26日
          </Text>
        </View>
      </Flex>
    </View>
  );
};

interface SectionProps {
  title: string;
  content: string;
}

const Section: React.FC<SectionProps> = ({ title, content }) => (
  <View>
    <Heading level={2} fontSize="large">{title}</Heading>
    <Divider marginBlock="medium" />
    <Text whiteSpace="pre-wrap">{content}</Text>
  </View>
);

```

### pages/comingsoon.tsx

```
// ComingSoonPage.tsx
import { View, Heading, Text } from '@aws-amplify/ui-react';

export const ComingSoonPage = () => {
  return (
    <View
      style={{
        backgroundColor: 'var(--amplify-colors-background-secondary)',
        minHeight: '90vh',
        display: 'flex',
        justifyContent: 'center',
        alignItems: 'center',
        padding: '2rem'
      }}
    >
      <View
        style={{
          backgroundColor: 'var(--amplify-colors-background-primary)',
          padding: '2rem',
          borderRadius: 'var(--amplify-radii-xl)',
          boxShadow: 'var(--amplify-shadows-medium)',
          maxWidth: '600px',
          width: '100%',
          textAlign: 'center'
        }}
      >
        <View
          style={{
            fontSize: '3rem',
            marginBottom: '1rem'
          }}
        >
          🔮
        </View>
        
        <Heading
          level={1}
          style={{
            color: 'var(--amplify-colors-font-primary)',
            fontSize: '2rem',
            marginBottom: '1rem'
          }}
        >
          Coming Soon
        </Heading>
        
        <Text
          style={{
            color: 'var(--amplify-colors-font-secondary)',
            fontSize: '1.1rem',
            marginBottom: '2rem'
          }}
        >
          このコンテンツは現在準備中です。
          もうしばらくお待ちください...
        </Text>

        <View
          style={{
            display: 'flex',
            justifyContent: 'center',
            gap: '0.5rem',
            marginTop: '2rem'
          }}
        >
          {[...Array(3)].map((_, i) => (
            <View
              key={i}
              style={{
                width: '0.5rem',
                height: '0.5rem',
                backgroundColor: 'var(--amplify-colors-secondary-60)',
                borderRadius: '50%',
                animation: `bounce ${i * 0.2 + 0.8}s infinite`
              }}
            />
          ))}
        </View>

        <style>
          {`
            @keyframes bounce {
              0%, 100% { transform: translateY(0); }
              50% { transform: translateY(-10px); }
            }
          `}
        </style>
      </View>
    </View>
  );
};
```

### pages/call/AboutPage.tsx

```
import { 
  Card, 
  Heading, 
  Text, 
  View,
  Divider,
  Flex,
  useTheme
} from '@aws-amplify/ui-react';
import { Helmet } from 'react-helmet-async';
import { ContentCard } from '../../components/common/ContentCard';

export const AboutPage = () => {
  const { tokens } = useTheme();

  return (
    <View>
      <Helmet>
        <title>はじめまして - Project Niferche</title>
        <meta name="description" content="Project Nifercheは、アイデアの共有を通して新しい物語を紡ぎ出す創発的な創作プロジェクトです。" />
      </Helmet>

      <View padding={tokens.space.large}>
        <Card variation="elevated" maxWidth="800px" margin="0 auto">
          <Heading 
            level={1}
            color="font.primary"
            textAlign="center"
            padding={tokens.space.medium}
          >
            はじめまして
          </Heading>
          
          <Text
            textAlign="center"
            fontSize="large"
            color="font.secondary"
            padding={tokens.space.medium}
          >
            Project Nifercheは、アイデアの共有を通して新しい物語を紡ぎ出す創発的な創作プロジェクトです。
          </Text>

          <Divider orientation="horizontal"  />
          
          <Heading 
            level={2}
            textAlign="center"
            padding={tokens.space.medium}
          >
            物語の世界へようこそ
          </Heading>

          <Flex 
            direction={{ base: 'column', medium: 'row' }}
            gap={tokens.space.medium}
            justifyContent="center"
            alignItems="center"
            marginTop={tokens.space.large}
          >
            
            <ContentCard
              title="メインストーリー"
              description="記憶を失った研究者サレジアと、彼が想像/創造した不思議な存在ニファーシェ。
                二人の出会いが織りなす、現実と想像の境界を超えた物語。"
              imagePath="/images/about_mainstory.jpg"
              linkTo="/laboratory/mainstory"
            />
            <ContentCard 
              title="サイドストーリー"
              description="魔法世界「Quxe」、未来世界「Hodemei」、そして不思議な異世界「Alsarejia」。
                これらの世界を結ぶ物語の背景をご紹介します。"
              imagePath="/images/about_sidestory.jpg"
              linkTo="/laboratory/sidestory"
            />
            <ContentCard 
              title="設定資料集"
              description="全ての物語に共通する法則や各個別世界に登場するキャラクターや組織に関する設定資料を公開"
              imagePath="/images/about_sidestory.jpg"
              linkTo="/materials/common"
            />

            
          </Flex>
        </Card>
      </View>
    </View>
  );
};
```

### pages/call/PhilosophyPage.tsx

```
// src/pages/call/PhilosophyPage.tsx
import {
  Card,
  Heading,
  Text,
  View,
  Flex,
  Button,
  Badge,
  Divider,
  Alert,
  useTheme
} from '@aws-amplify/ui-react';
import { Link } from 'react-router-dom';
import { Helmet } from 'react-helmet-async';

export const PhilosophyPage = () => {
  const { tokens } = useTheme();

  return (
    <>
      <Helmet>
        <title>理念 - Project Niferche</title>
        <meta
          name="description"
          content="Project Nifercheが掲げる理念と活動方針について"
        />
      </Helmet>

      <View padding={tokens.space.large}>
        <Card
          backgroundColor="background.primary"
          borderRadius="medium"
          padding={tokens.space.large}
          maxWidth="800px"
          margin="0 auto"
        >
          <Heading level={1} textAlign="center">
            理念
          </Heading>

          <Alert variation="info" margin={tokens.space.medium}>
            Project Nifercheは創作活動支援のためのプラットフォームです。
            特定の思想や信条を広めることを目的とした活動ではありません。
          </Alert>

          <Divider margin={tokens.space.large} />

          <Card backgroundColor="background.secondary" margin={tokens.space.medium}>
            <Badge variation="success">理念1</Badge>
            <Heading level={3}>人類の精神的豊かさの追求</Heading>
            <Text padding={tokens.space.small}>
              創造活動による自己実現の支援を通じて、社会的問題の解決にも貢献します。
              オープンな創作環境および設定資料集の提供、オープンデータセットの作成と管理を行います。
            </Text>
            <Flex
              direction={{ base: 'column', medium: 'row' }}
              gap={tokens.space.medium}
              justifyContent="center"
              alignItems="center"
              marginTop={tokens.space.large}
            >
              <Link to="/rights" style={{ textDecoration: 'none' }}>
                <Button variation="link">権利情報</Button>
              </Link>
              <Link to="/guidelines" style={{ textDecoration: 'none' }}>
                <Button variation="link">ガイドライン</Button>
              </Link>
            </Flex>
          </Card>

          <Card backgroundColor="background.secondary" margin={tokens.space.medium}>
            <Badge variation="info">理念2</Badge>
            <Heading level={3}>ループ構造の維持</Heading>
            <Text padding={tokens.space.small}>
              本理念の詳細な理解には創作世界の深い知識が必要です。
              A2のサレジアが研究活動のために利用可能なアイデア資源の確保を目指し、
              交流プラットフォーム「Laboratory Alsarejia」を提供します。
            </Text>
            <Flex justifyContent="flex-end" padding={tokens.space.small}>
              <Link to="/library/mainstory" style={{ textDecoration: 'none' }}>
                <Button variation="primary">メインストーリーを読む</Button>
              </Link>
            </Flex>
          </Card>

          <Divider margin={tokens.space.large} />

          <Heading level={3} textAlign="center">
            最新のお知らせ
          </Heading>
          <Card margin={tokens.space.medium}>
            <Text color="font.secondary">お知らせはまもなく実装されます</Text>
          </Card>
        </Card>
      </View>
    </>
  );
};

```

### pages/call/NewsPage.tsx

```
// src/pages/call/NewsPage.tsx
import { 
  Card, 
  Heading, 
  Text, 
  View,
  Collection,
  Badge,
  Flex,
  useTheme 
} from '@aws-amplify/ui-react';

interface NewsItem {
  id: string;
  title: string;
  content: string;
  date: string;
  category: 'update' | 'event' | 'important';
  isNew: boolean;
}

const newsItems: NewsItem[] = [
  {
    id: '1',
    title: '研究施設の大規模アップデート',
    content: 'Laboratory Alsarejiaに新しい観測機能が追加されました。',
    date: '2024-03-20',
    category: 'update',
    isNew: true
  },
  // ... その他のニュース項目
];

export const NewsPage = () => {
  const { tokens } = useTheme();

  return (
    <View padding={tokens.space.large}>
      <Card>
        <Heading level={1}>ニファーシェからのお知らせ</Heading>
        <Collection
          items={newsItems}
          type="list"
          gap={tokens.space.medium}
          padding={tokens.space.large}
        >
          {(item) => (
            <Card key={item.id}>
              <Flex justifyContent="space-between" alignItems="center">
                <Heading level={3}>{item.title}</Heading>
                {item.isNew && (
                  <Badge variation="success">NEW</Badge>
                )}
              </Flex>
              <Text>{item.content}</Text>
              <Text variation="tertiary">{item.date}</Text>
            </Card>
          )}
        </Collection>
      </Card>
    </View>
  );
};
```

### pages/MainPage.tsx

```
// src/pages/MainPage.tsx
import {
  Heading,
  View,
  Text,
  Button,
  Flex,
  useTheme
} from '@aws-amplify/ui-react';
import { Link } from 'react-router-dom';
import { Helmet } from 'react-helmet-async';
import { ContentCard } from '../components/common/ContentCard';

// ニュース例
const newsItems = [
  {
    date: '2024.11.24',
    text: 'Webサイトをリニューアルしました'
  },
  {
    date: '2024.11.23',
    text: 'メインストーリー第一章を公開しました'
  },
  {
    date: '2024.11.22',
    text: 'Laboratory Alsarejiaの設定資料を追加しました'
  }
];

export const MainPage = () => {
  const { tokens } = useTheme();

  return (
    <>
      <Helmet>
        <title>Project Niferche</title>
        <meta
          name="description"
          content="Project Nifercheは、アイデアの共有を通して新しい物語を紡ぎ出す創発的な創作プロジェクトです。"
        />
      </Helmet>

      {/* ヒーローセクション */}
      <Flex
        direction="column"
        alignItems="center"
        justifyContent="center"
        padding={{ base: 'medium', large: 'xxl' }}
        height="80vh"
        style={{
          backgroundImage: 'url("../images/sc.jpg")',
          backgroundSize: 'cover',
          backgroundPosition: 'center',
          position: 'relative'
        }}
      >
        {/* 背景オーバーレイ */}
        <View
          style={{
            position: 'absolute',
            top: 0,
            left: 0,
            right: 0,
            bottom: 0,
            backgroundColor: 'rgba(0, 0, 0, 0.5)'
          }}
        />

        {/* メインコンテンツ */}
        <Flex
          direction="column"
          alignItems="center"
          gap="large"
          style={{ position: 'relative', zIndex: 1 }}
        >
          <Heading
            level={1}
            color={tokens.colors.white}
            fontSize={{ base: tokens.fontSizes.xxxl, large: '4rem' }}
            textAlign="center"
          >
            Project Niferche
          </Heading>

          <Text
            color={tokens.colors.white}
            textAlign="center"
            maxWidth="900px"
            padding="medium"
          >
            「人類は高度な情報交換システムを有する情報社会に到達しました。<br />
            しかし、急速な技術の発展に対し、文化・精神の成熟は非常に緩やかなものです。<br />
            皆様の精神の充実と輝かしい個性の発現を願い、我々は灯火を掲げます。」
          </Text>

          <Flex direction="row" gap="medium">
            <Button
              as={Link}
              to="/call/about" // 修正箇所: もともと "/about" を "/call/about" に
              variation="primary"
              size="large"
            >
              プロジェクトについて
            </Button>
            <Button
              as={Link}
              to="/laboratory/about"
              variation="primary"
              size="large"
            >
              Laboratory へ
            </Button>
          </Flex>
        </Flex>
      </Flex>

      {/* ニュースセクション */}
      <View
        backgroundColor={tokens.colors.background.secondary}
        padding={{ base: 'medium', large: 'xl' }}
      >
        <Flex direction="column" maxWidth="1200px" margin="0 auto" gap="medium">
          <Heading level={3}>ニファーシェからのお知らせ</Heading>
          <Flex direction="column" gap="small">
            {newsItems.map((item, index) => (
              <Flex
                key={index}
                direction="row"
                gap="medium"
                padding="small"
                backgroundColor={
                  index === 0 ? tokens.colors.background.primary : undefined
                }
                borderRadius="small"
              >
                <Text fontWeight="bold">{item.date}</Text>
                <Text>{item.text}</Text>
              </Flex>
            ))}
          </Flex>
        </Flex>
      </View>

      {/* フィーチャーセクション */}
      <View padding={{ base: 'medium', large: 'xl' }}>
        <Flex direction="column" maxWidth="1200px" margin="0 auto" gap="xl">
          <Heading level={2}>主なコンテンツ</Heading>

          <Flex
            direction={{ base: 'column', large: 'row' }}
            gap="large"
            alignItems="stretch"
          >
            <ContentCard
              title="メインストーリー"
              description="記憶を失った研究者サレジアと、不思議な存在ニファーシェの物語"
              imagePath="/images/main-story.jpg"
              linkTo="/library/mainstory"
            />

            <ContentCard
              title="Laboratory"
              description="創作活動の拠点となる研究施設、あなたの想像が新しい物語を生み出します"
              imagePath="/images/laboratory.jpg"
              linkTo="/laboratory/about"
            />

            <ContentCard
              title="世界設定資料"
              description="Quxe、Hodemei、Alsarejiaの3つの世界の詳細な設定資料"
              imagePath="/images/worlds.jpg"
              linkTo="/materials/common"
            />
          </Flex>
        </Flex>
      </View>

      {/* コミュニティセクション */}
      <View
        backgroundColor={tokens.colors.background.secondary}
        padding={{ base: 'medium', large: 'xl' }}
      >
        <Flex
          direction="column"
          maxWidth="1200px"
          margin="0 auto"
          gap="large"
          alignItems="center"
        >
          <Heading level={2} textAlign="center">
            創作の輪に参加しませんか？
          </Heading>
          <Text textAlign="center" maxWidth="600px">
            Laboratory Alsarejiaでは、あなたのアイデアや創作物を共有し、
            新しい物語を一緒に紡ぎ出すことができます。
          </Text>
          <Button as={Link} to="/call/about" variation="primary" size="large">
            参加方法を確認する
          </Button>
        </Flex>
      </View>
    </>
  );
};

```

### pages/NotFoundPage.tsx

```
// src/pages/NotFoundPage.tsx
import { View, Heading, Button } from '@aws-amplify/ui-react';
import { useNavigate } from 'react-router-dom';

export const NotFoundPage = () => {
  const navigate = useNavigate();

  return (
    <View padding="2rem" textAlign="center">
      <Heading level={1}>404 - Page Not Found</Heading>
      <Button onClick={() => navigate('/')} marginTop="1rem">
        メインページに戻る
      </Button>
    </View>
  );
};
```

### services/mockStorage.tsx

```
// src/services/mockStorage.ts
import { LabDocument, LabCategory } from '../types/laboratory';

export interface ContentData {
  body: string;
  metadata?: Record<string, any>;
}

interface ImageContent {
  path: string;
  fallback: string;
}

// イメージのモックデータ
const MOCK_IMAGES: Record<string, ImageContent> = {
  'main-story': {
    path: '/images/main-story.jpg',
    fallback: '/images/fallback.jpg'
  },
  'worlds': {
    path: '/images/worlds.jpg',
    fallback: '/images/fallback.jpg'
  },
  'laboratory': {
    path: '/images/laboratory.jpg',
    fallback: '/images/fallback.jpg'
  },
  'facility-map': {
    path: '/images/laboratory/facility-map.jpg',
    fallback: '/images/fallback.jpg'
  }
};

// アイデアドキュメントのモックデータ
const MOCK_IDEA_DOCS: Record<string, LabDocument[]> = {
  'basic': [
    {
      id: 'idea-basis',
      title: 'アイデア体の基礎',
      description: 'アイデア体とその性質についての基本的な解説',
      category: LabCategory.IDEA,
      reference: 'IDA-001',
      isAvailable: true,
      variant: 'document'
    },
    {
      id: 'idea-structure',
      title: 'アイデア構造論',
      description: 'アイデア体の内部構造と相互作用',
      category: LabCategory.IDEA,
      reference: 'IDA-002',
      isAvailable: true,
      variant: 'document'
    }
  ],
  'advanced': [
    {
      id: 'idea-resonance',
      title: '共鳴現象',
      description: 'アイデア体間の共鳴と増幅に関する研究',
      category: LabCategory.IDEA,
      reference: 'IDA-003',
      isAvailable: true,
      variant: 'document'
    },
    {
      id: 'idea-lifecycle',
      title: 'ライフサイクル',
      description: 'アイデア体の生成から消滅までの過程',
      category: LabCategory.IDEA,
      reference: 'IDA-004',
      isAvailable: false,
      variant: 'document'
    }
  ],
  'research': [
    {
      id: 'idea-measurement',
      title: '観測方法論',
      description: 'アイデア体の観測と記録の手法',
      category: LabCategory.IDEA,
      reference: 'IDA-005',
      isAvailable: true,
      variant: 'document'
    }
  ]
};

// 施設ドキュメントのモックデータ
const MOCK_FACILITY_DOCS: Record<string, LabDocument[]> = {
  'overview': [
    {
      id: 'facility-map',
      title: '施設マップ',
      description: 'アルサレジア研究所の全体マップです',
      category: LabCategory.FACILITY,
      reference: 'FAC-001',
      isAvailable: true,
      variant: 'image',
      imagePath: '/images/laboratory/facility-map.jpg'
    }
  ],
  'areas': [
    {
      id: 'facility-security',
      title: 'セキュリティガイド',
      description: '研究所内での安全管理と機密情報の取り扱いについて',
      category: LabCategory.FACILITY,
      reference: 'FAC-003',
      isAvailable: true,
      variant: 'document'
    },
    {
      id: 'facility-resources',
      title: '設備・リソース',
      description: '利用可能な研究設備とリソースの一覧',
      category: LabCategory.FACILITY,
      reference: 'FAC-004',
      isAvailable: false,
      variant: 'document'
    }
  ],
  'rules': [
    {
      id: 'facility-rules',
      title: '利用規約',
      description: '研究所の利用に関する基本的な規則と注意事項',
      category: LabCategory.RULES,
      reference: 'FAC-002',
      isAvailable: true,
      variant: 'document'
    }
  ]
};

// テキストコンテンツのモックデータ
const MOCK_CONTENT: Record<string, ContentData> = {
  'stories/main/chapter1.txt': {
    body: '第1章のサンプルテキスト...\nここに本文が入ります。\n\n詳細な内容はこれから追加されます。',
    metadata: {
      title: '第1章',
      author: 'サレジア',
      version: '1.0.0'
    }
  },
  'stories/main/chapter2.txt': {
    body: '第2章のサンプルテキスト...\nここに本文が入ります。\n\n詳細な内容はこれから追加されます。',
    metadata: {
      title: '第2章',
      author: 'サレジア',
      version: '1.0.0'
    }
  },
  'laboratory/ideas/basic-concept.md': {
    body: 'アイデア体の基本概念に関する説明...\n\n1. アイデア体とは\n2. 基本的な性質\n3. 観測方法\n\n詳細な内容はこれから追加されます。',
    metadata: {
      title: 'アイデア体の基本概念',
      category: LabCategory.IDEA,
      reference: 'IDA-001'
    }
  },
  'laboratory/facility/rules.md': {
    body: '研究所の利用規約と注意事項...\n\n1. 一般的な注意事項\n2. セキュリティ規則\n3. 緊急時の対応\n\n詳細な内容はこれから追加されます。',
    metadata: {
      title: '研究所利用規約',
      category: LabCategory.RULES,
      reference: 'FAC-002'
    }
  }
};

// MockStorageServiceクラス
export class MockStorageService {
  static async getText(path: string): Promise<string> {
    const content = MOCK_CONTENT[path];
    if (!content) {
      throw new Error('Content not found');
    }
    return content.body;
  }

  static async getImage(path: string): Promise<string> {
    const image = MOCK_IMAGES[path];
    if (!image) {
      return '/images/fallback.jpg';
    }
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(image.path);
      img.onerror = () => resolve(image.fallback);
      img.src = image.path;
    });
  }

  static async getFacilityDocuments(section: string): Promise<LabDocument[]> {
    const docs = MOCK_FACILITY_DOCS[section];
    if (!docs) {
      return [];
    }
    return docs;
  }

  static async getIdeaDocuments(category: string): Promise<LabDocument[]> {
    const docs = MOCK_IDEA_DOCS[category];
    if (!docs) {
      return [];
    }
    return docs;
  }

  static async getMetadata(path: string): Promise<Record<string, any>> {
    const content = MOCK_CONTENT[path];
    if (!content || !content.metadata) {
      throw new Error('Metadata not found');
    }
    return content.metadata;
  }

  static async getAllContent(): Promise<Record<string, ContentData>> {
    return MOCK_CONTENT;
  }

  static async getContentsByCategory(category: string): Promise<ContentData[]> {
    return Object.entries(MOCK_CONTENT)
      .filter(([_, content]) => content.metadata?.category === category)
      .map(([_, content]) => content);
  }

  static async isContentAvailable(path: string): Promise<boolean> {
    return path in MOCK_CONTENT;
  }

  static async isImageAvailable(path: string): Promise<boolean> {
    return path in MOCK_IMAGES;
  }

  static getFallbackImage(): string {
    return '/images/fallback.jpg';
  }

  static simulateNetworkError(): Promise<never> {
    return Promise.reject(new Error('Network error'));
  }
}
```

### services/storage.tsx

```
// src/services/storage.tsx
import { MockStorageService } from './mockStorage';

// 実際のAWS Storage操作の代わりにモックサービスをエクスポート
export const StorageService = MockStorageService;
```

### services/auth.ts

```
// src/services/auth.ts
import { 
  signUp,
  confirmSignUp,
  resetPassword,
  confirmResetPassword,
  updateUserAttributes,
  UserAttributeKey
} from 'aws-amplify/auth';
import { generateClient } from 'aws-amplify/api';
import type { Schema } from '../../amplify/data/resource';

const client = generateClient<Schema>();

export const authService = {
  // サインアップ
  async signUp(username: string, password: string, email: string) {
    try {
      const result = await signUp({
        username,
        password,
        options: {
          userAttributes: {
            email
          }
        }
      });
      
      // UserProfileの作成
      if (result.userId) {
        await client.models.UserProfile.create({
          userId: result.userId,
          email,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          badges: []
        });
      }
      
      return result;
    } catch (error) {
      console.error('Sign up error:', error);
      throw error;
    }
  },

  // サインアップ確認
  async confirmSignUp(username: string, confirmationCode: string) {
    try {
      return await confirmSignUp({
        username,
        confirmationCode
      });
    } catch (error) {
      console.error('Confirm sign up error:', error);
      throw error;
    }
  },

  // パスワードリセットの開始
  async initiateResetPassword(username: string) {
    try {
      return await resetPassword({ username });
    } catch (error) {
      console.error('Reset password error:', error);
      throw error;
    }
  },

  // パスワードリセットの確認
  async confirmResetPassword(username: string, newPassword: string, confirmationCode: string) {
    try {
      return await confirmResetPassword({
        username,
        newPassword,
        confirmationCode
      });
    } catch (error) {
      console.error('Confirm reset password error:', error);
      throw error;
    }
  },

  // ユーザー属性の更新
  async updateUserProfile(attributes: { [key in UserAttributeKey]?: string }) {
    try {
      return await updateUserAttributes({
        userAttributes: attributes
      });
    } catch (error) {
      console.error('Update user attributes error:', error);
      throw error;
    }
  }
};
```

